{"searchDocs":[{"title":"IPS产品经理","type":0,"sectionRef":"#","url":"/blog/2018/ips-product-designer","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"吐槽​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#吐槽","content":"2017 年 8 月, 我被转岗了. 转岗后, 我遇见了很多不曾想过的奇葩人 奇葩事. 本文仅从我个人角度, 描述我看到的, 一位新人产品经理, 如何从相识, 到相知, 然后走到了开发的对立面. 本文充满了个人情感, 完全作为吐槽用, 或许并不客观, 但保证所述为真材实料. 批评不自由, 则赞美无意义. ","version":null,"tagName":"h2"},{"title":"初来​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#初来","content":"大概是 8 9 月份某天吧, 这位并不萌的新产品经理来了, 被另一位产品经理带着, 和组里所有的开发&amp;测试同学, 挨个碰了个面, 混了个脸熟. 由于我在新组里, 一直处于游离态, 只加了一个群, 实在看不到这位产品经理来的时间, 只能凭印象了. 说实话, 第一感觉不是很好, 换句话说, 毫无理由, 我并不喜欢这位产品经理. 不过虽然不怎么待见人家, 我还是希望她段位高一些的, 起码让我这种想躺赢的, 能躺的舒服些 😜 我这个人可能比较二, 或者是迷? 我很看重和陌生人第一次见面的感觉. 这个感觉, 从学生时代到现在, 整体偏准, 起码比我王者荣耀的胜率高多了. 那个, 戴口罩, 以及生病的不算. ","version":null,"tagName":"h3"},{"title":"平静​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#平静","content":"10 月份前后, 由于正在进行的项目需求已定, 也有可能是我没有进入到敌军核心, 了解不到高层信息, 新来的产品经理貌似没有什么施展拳脚的机会. 整体上, 这段时间我们就像两条平行线. 如果不是偶尔来这边找人, 我都忘了有这么号产品经理了... ","version":null,"tagName":"h3"},{"title":"成长​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#成长","content":"10 月末, 接到了一个管理平台的定制, 用来参加入围测试. 需要新开发一些功能. 需求讨论会上, 是我第一次和这位接触. 一共几次会议, 这位话不多, 很平静. 只是偶尔的几句, 我们能做就做吧, 功能越多越好, 显得略微有些刺耳. 我觉得这位产品经理, 已经熟悉了一些产品特性, 但她可能还没有吃透, 她还有进步的空间. ","version":null,"tagName":"h3"},{"title":"暴雨前夕​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#暴雨前夕","content":"无聊的时间总是过得很快, 一晃就年底. 转岗几个月, 正儿八经的代码基本没写, 光熟悉现有的坑, 和前面提到的, 我自己埋的那个入围测试的坑了. 这段时间, 能拿出来念叨念叨的事, 也就是做了 2 个 RG 独角兽, 2 个 PG 独角兽, 还有一些其他的模型. emmm, 做龙桃子独角兽的时候, 因为某同学的一句话, 导致心神恍惚, 左手血祭了. ","version":null,"tagName":"h3"},{"title":"双龙出海​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#双龙出海","content":"新年新气象, 在新的一年里, 大家也都开始各显神通. 每年年初, 大家都开始为今年产品发展的方向做规划, 我们也不例外. 可能我在转岗前, 和总监谈话的过程中, 说了些有点用处的想法, 我这名搬砖选手, 也参与了一次规划会. 会议上&quot;领导们&quot;讨论了很多, 机器学习 大数据 虚拟化 云等高大上的名词映入眼帘, 让我产生了今年要忙死的感觉, 这么多新技术, 肯定比去年血祭高达强多了. 为了适应市场需要, 今年的重点有两个. 补足管理平台的分析能力和强化盒子的检测能力, 并完成二者的联动. 在五月份发布, 推向市场, 以便迎合三四季度冲量的目标. 方向定下后, 就要考虑如何更好 更高效 更平稳的落实在产品上, 高保真原型 需求文档必不可少. 我们这位已经不算新人的产品经理, 接下了高保真原型这份重担. 其中, 需求文档的梳理, 由一位 SE 负责, 最后他们一起梳理, 相辅相成, 为我们产品的发展, 添砖加瓦. 如果我非常闲, 有可能会再介绍下这位厉害的 SE😜 ","version":null,"tagName":"h3"},{"title":"初露锋芒​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#初露锋芒","content":"燕子归来, 春暖花开, 转眼来到了万物复苏的季节. 我只搬管理平台的砖, 前面提到的年度任务, 需要产品经理的原型和 SE 的需求文档有个大致的脉络后, 我才能开始搬砖. 然鹅, 17 年底提出了 18 年核心项目的方案. 几个月过去, 小花马上就开了, 我们的产品经理还在辛苦的梳理需求, 设计原型. 我在一个偶然的情况下, 见到了一次貌似要给我用的, 用 Axure 做的原型. emmm, 怎么形容呢, 一言难尽吧, 省略 500 字.  产品经理这么辛苦, SE 肯定也不能闲着, 毕竟他俩得互帮互助, 相辅相成呢. SE 特地从成都跑到北京出差半个月, 据说是赶过来&quot;帮我&quot;梳理需求. 结果是显然的, 我不知道 SE 是如何梳理需求的, 也不清楚他有没有圆满完成任务, 更没看见梳理好的需求包文档. 但是, 我确确实实听他在工位哼了两周的歌, 不要钱的那种. ","version":null,"tagName":"h3"},{"title":"GTMD​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#gtmd","content":"万事俱备, 东风已来, 那就搬起砖来? GTMD, 我还是太年轻了. 说实话, 已经记不清是 18 年几月份, 反正到了穿短袖的季节. 产品经理扔给我们个 Axure 画的&quot;高保真&quot;原型, SE 掏出份需求包文档. 由于 Axure 这软件太高端, 我等傻搬砖的如何会用这么金贵的东西. 再说了, 就算会用, 也没那么高的抽象艺术解析力呀, 我还是看需求包文档吧. 那直白的描述, 平铺直叙的文档脉络, 满屏幕, 只有主语不同的句式, 多 TMD 浅显易懂. 果然技术出身的 SE 更懂人心, 知道我等理解能力不行, 又没啥抽象派的艺术细胞, 给了个这么接地气的 Excel🙃  花了几周, 把之前那些接地下气的代码重写一部分. 又接着地气开发了俩月. 产品经理在评审会上认为我按照需求包文档搬的砖, 不符合日日更新的&quot;高保真&quot;原型设计, 需要重做. 我一个搬砖的能怎么办, 肯定得找牛人 SE 来帮忙啊. 让我没想到的是, 牛人也有牛人的烦恼. 当南北两大家齐聚一堂, 共议需求时, 会产生何种的化学反应? 当然是各有各的尊严, 据理力争. 没有什么是一次会议解决不了的, 如果有, 那就多来几次. 直到搁置争议, GTMD. GTMD, 代指&quot;共同面对&quot;. 出自王者荣耀, 四冠王战队 QGHappy, 中单选手伪装. ","version":null,"tagName":"h3"},{"title":"忽忽悠悠​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#忽忽悠悠","content":"太极生两仪, 两仪生四象, 四象生八卦~ 产品经理认为需求包文档不合理, 要求舍弃需求包文档, 按照日日更新的&quot;高保真&quot;原型来做. 作为一个在其他团队搬过砖的选手, 对这种要求, 我肯定是拒绝的. 然鹅, 对于我的不配合, 产品经理非常不满, 问我: 为什么别人家都能把砖砌成双子塔, 而我们只能守着小钟楼? 我无言以对, 只能用上无师自通的太极八卦之术来应对. emmm, 就是和稀泥. 经过几个小时的努力, 写了俩月的代码, 基本可以半重构了. 至于发布日期, 抱歉, 我司 deadline 不就是拿来延的么? ","version":null,"tagName":"h3"},{"title":"硝烟再起​","type":1,"pageTitle":"IPS产品经理","url":"/blog/2018/ips-product-designer#硝烟再起","content":"春夏秋冬, 一年四季. 转眼就快能吃冬至的饺子了. 去年计划今年 5 月, 发布我们的&quot;单子塔&quot;. 由于开发能力不足, 无法适应日新月异的新需求. 我们的产品, 已经维持了几个月的&quot;马上发布&quot;阶段. 上周五例会, 所有不管相关不相关的人员, 聚集一堂, 看着管理平台那 37 个 later 状态的八阿哥, 为他们选择归途. 我那的功能, 再次出现了争议. 从按照需求包文档不行, 改成跟随日日更新&quot;高保真&quot;开发. 结果这次会议上, &quot;高保真&quot;貌似也不合心意了, 需要重新讨论需求. 涉及到需求的讨论, 那肯定产品经理和 SE 两位大佬商议, 而商议的结果, 在周一上午草草出场, 看不到一丝心血. 不要问我和前面那个图有什么区别, 我也不知道.  我出离的愤怒, 在微信群里对产品经理发出了质问. 果然, 依旧是搁置争议, SP 版本再说.  懒得多说什么了, 还是写写文档吐吐槽, 多写代码多看书, 早睡早起身体好. 另祝大家早日上王者. ","version":null,"tagName":"h3"},{"title":"《扫鼠岭》","type":0,"sectionRef":"#","url":"/blog/2021/book3","content":"2021 年的第三本书 2021 年的第三本书《扫鼠岭》 推理小说，不同于网文白开水式的全篇叙述，对场面描写有一定的要求。而作者呼延云，也确实做到了。因为，大部分场景，我仅仅是看过，根本不会在脑海中去构建“映像”。 西郊旧案，猜到了案件的起因、经过、结局。可惜是凭借本能，而非推导。看完后，才觉得有些浪费了。但或许是核酸检测结果迟迟不出，也可能跟不敢去复原场景有些许关系。总之，有些浪费了。 扫鼠岭案，心不静。仅仅作为看客，过了一遍剧情。连“读”都算不上。但“装一个坏人活给世界，做一个好人活给自己”这句话，很不错。充分描绘了周立平的作为与悲哀。 结局惨淡，但符合全局。正义不会迟到。可迟来的正义，只能审判罪恶，不能挽回罪行。","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"前端框架预研","type":0,"sectionRef":"#","url":"/blog/2019/fronted-framework","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"前端框架预研​","type":1,"pageTitle":"前端框架预研","url":"/blog/2019/fronted-framework#前端框架预研","content":"因设备前端框架, UI 组将停止维护, 故进行新框架选型. 本文的主要针对热度较高的 Angular React Vue 进行预研. ","version":null,"tagName":"h2"},{"title":"Angular​","type":1,"pageTitle":"前端框架预研","url":"/blog/2019/fronted-framework#angular","content":"简介​ 由 Google 开发, 从 Angular2 开始, 使用 Typescript 语言进行开发. 相关性​ ESPC 前端框架为 AngularJS 1.3.15, 但 Angular 2 与 1 相差很多upgrade 套件, 拥有一定的多版本并存特性, 但仍需二次开发&amp;测试公司部分项目使用了新版本的 AngularUI 组可提供组件库 需学习​ TypescriptAngular ","version":null,"tagName":"h3"},{"title":"React​","type":1,"pageTitle":"前端框架预研","url":"/blog/2019/fronted-framework#react","content":"简介​ 由 Facebook 开发, 灵活的 JSX 语法. 相关性​ 公司部分项目使用 React 进行开发UI 组可提供组件库 需学习​ ReactJSX ","version":null,"tagName":"h3"},{"title":"Vue​","type":1,"pageTitle":"前端框架预研","url":"/blog/2019/fronted-framework#vue","content":"简介​ 由个人开发者开发, 上手门槛低 相关性​ waf 有使用 Vue 进行开发的项目UI 组目前无 Vue 相关组件库 需学习​ Vue  ","version":null,"tagName":"h3"},{"title":"对比​","type":1,"pageTitle":"前端框架预研","url":"/blog/2019/fronted-framework#对比","content":"React Vue 在 GitHub 均拥有 14w+-的 star, Angular 不到 5wVue 打包体积仅 20kb, React 为 30+-, Angular 接近 100State Of JS 报告, React Vue 占据明显优势, Angular 有近 40%开发者不想使用Vue 学习成本最低, React 次之, Angular 较高三框架均需学习 npm 基础操作, 及框架相关的工具链 ","version":null,"tagName":"h3"},{"title":"理解RESTful API","type":0,"sectionRef":"#","url":"/blog/2021/RESTful API","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"愿景​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#愿景","content":"明确清晰的 API 结构, 方便协作开发, 向后升级 ","version":null,"tagName":"h2"},{"title":"什么是 RESTful API​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#什么是-restful-api","content":"面向资源类型的接口风格 ","version":null,"tagName":"h2"},{"title":"避免 RESTful 陷阱​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#避免-restful-陷阱","content":"RESTful 的目标, 是帮助人们更好的开发&amp;协作. 当项目需求, 和 RESTful 建议相悖时, 要灵活多变! 不要为了 RESTful 而 RESTful REST 并没有一个明确的标准，而更像是一种设计的风格 ","version":null,"tagName":"h2"},{"title":"URL 结构​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#url-结构","content":"URL = scheme://host:port/path[?query][#fragment] scheme: 指底层用的协议, 如 http, https, ftp host: 服务器的 IP 地址或者域名 port: 端口, http 默认为 80 path: 访问资源的路径, 即 web 框架中的路由 route query: 查询字符串, 发给服务器的参数 fragment: 锚点, 定位到页面的资源 ? 这个, 其实没太理解 ","version":null,"tagName":"h2"},{"title":"path 格式​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#path-格式","content":"/{version}/{resource}/{resource-id}/{sub-resource}/{sub-resource-id}/action 原则上, 使用 http 动词, 作为 api 动词. url 中, 不使用动词. 但是, 当 CURD 无法满足需求时, 在尾部增加动词, 以满足需求 ","version":null,"tagName":"h2"},{"title":"URL 规范​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#url-规范","content":"所有字母小写连字符使用-而非_使用/表明层级. 越靠前的层级, 应该相对稳定尾部不应包含/URL 中, 不出现动词, 用请求方式表示动作资源表示用复数 ","version":null,"tagName":"h2"},{"title":"HTTP 动词​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#http-动词","content":"GET: selectPOST: createPUT: updatePATCH: updateDELETE: delete ","version":null,"tagName":"h2"},{"title":"参考​","type":1,"pageTitle":"理解RESTful API","url":"/blog/2021/RESTful API#参考","content":"http://www.ruanyifeng.com/blog/2014/05/restful_api.html https://www.cnblogs.com/bigsai/p/14099154.html ","version":null,"tagName":"h2"},{"title":"UES之斗智斗勇","type":0,"sectionRef":"#","url":"/blog/2021/ues","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"简介​","type":1,"pageTitle":"UES之斗智斗勇","url":"/blog/2021/ues#简介","content":"个人 PC 检查, 换成了 UES 这种自动化工具, 本来是件好事... 但后台每小时扫描一次, 还不能装向日葵, 真就是有病了 ","version":null,"tagName":"h2"},{"title":"无耻之徒​","type":1,"pageTitle":"UES之斗智斗勇","url":"/blog/2021/ues#无耻之徒","content":"后台每小时扫描上报, 已经没有信任可言了向日葵被评为风险软件, 那倒是让前场别用了, 问题也不要解决了无法主动停用/卸载, 真~流氓软件 ","version":null,"tagName":"h2"},{"title":"win10 提权​","type":1,"pageTitle":"UES之斗智斗勇","url":"/blog/2021/ues#win10-提权","content":"C:\\Windows\\System32\\nsfagent.dll 属性安全-&gt;高级更改所有者-&gt;users编辑权限-&gt;Users 增加完全控制权限此时, nsfagent.dll 文件为可删除状态 ","version":null,"tagName":"h2"},{"title":"terminal 终止进程​","type":1,"pageTitle":"UES之斗智斗勇","url":"/blog/2021/ues#terminal-终止进程","content":"taskkill -f -pid 2872  有可能, 需要用管理员身份, 登录 cmd ","version":null,"tagName":"h2"},{"title":"醋的选购--理论篇","type":0,"sectionRef":"#","url":"/blog/2021/vinegar","content":"买调味品，参考国标，一般不会太坑。 醋的选购--理论篇 早起，收到罗大伦频道推送的食疗方——醋泡黑豆。貌似可以养头发，对于一个程序猿来说，非常值得尝试。 可问题来了，醋应该怎么买呢？作为早饭后的消食活动，这篇采买指南，就诞生了。 首先，看包装上的标准代号，符合 GB/T 18187-2000 的产品，为酿造食醋。配料一般仅有粮食，少部分产品含有苯甲酸钠，作防腐之用。如果标准代号为 SB/T 10337-2012，那就要小心了。这类产品属于“配制食醋”。配料为部分酿造食醋，与添加剂调和而成。emmm。。大概意思就是“勾兑”。虽然符合国家食品标准，但从个人角度，建议购买酿造食醋。 其次，看酸度。配制食醋，乙酸含量大于等于 2.5g/100ml。而酿造食醋，需要大于等于 3.5g/100ml。总酸度越高，品质越好，味道越加醇厚，更能抵抗细菌污染，易于保存。这也是为什么，有些酿造食醋，不需要添加苯甲酸钠的原因。 另外，据网上资料显示，品质越好的酿造食醋，摇晃瓶身时，会产生不易消退的泡沫。也算是一种鉴别方式，待我回头去超市实践一番，看是否灵验。 最后，山西老陈醋，江苏镇江香醋，四川保宁醋，福建永春老醋名扬四海，被称为“中国四大名醋”。我还没买过，有经验或者有兴趣的同学，欢迎交流经验。","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"外域副本任务奖励 联盟萨满视角","type":0,"sectionRef":"#","url":"/blog/2021/wow-sama","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"地狱火堡垒​","type":1,"pageTitle":"外域副本任务奖励 联盟萨满视角","url":"/blog/2021/wow-sama#地狱火堡垒","content":"地狱火城墙 攻陷城墙 |名称|类型|偏向| |---|---|---| |精确手甲|锁|增强| |翡翠战士肩铠|板|近战| |魔法力量护肩|布|元素| |稳步皮靴|皮|增强| 鲜血熔炉 鲜血就是生命 |名称|类型|偏向| |---|---|---| |惩戒胸甲|板|惩戒骑| |致命钻孔虫护腿|布|元素| |枭兽头饰|皮|元素| |缀鳞毁灭护腿|锁|元素|愤怒之心 |名称|类型|偏向| |---|---|---| |清澈火红坠饰|项链|元素| |神圣治疗指环|戒指|恢复| |完美平衡披风|披风|增强| 破碎大厅 扭转战局 |名称|类型|偏向| |---|---|---| |奈瑟库斯的痛苦魔杖|魔杖|DPS| |苏醒斗篷|披风|恢复| |纳利库的复仇|戒指|增强| |警醒卫士勋章|项链|T|邪部落的荣耀邪能灰烬 |名称|类型|偏向| |---|---|---| |助理牧师长靴|布|恢复| |符文蚀刻腰带|锁|增强| |维护手套|皮|恢复| |远征军斥候护肩|皮|增强| |无惧护手|板|T|堡垒中的囚徒 H荣耀堡的崇敬 ","version":null,"tagName":"h2"},{"title":"奥金顿​","type":1,"pageTitle":"外域副本任务奖励 联盟萨满视角","url":"/blog/2021/wow-sama#奥金顿","content":"塞泰克大厅 兄弟反目 |名称|类型|偏向| |---|---|---| |塞泰克先知颈环|项链|元素| |塞泰克神谕项链|项链|恢复| |利爪领主的项圈|项链|增强| |乌鸦卫士的印记|项链|T|泰罗克的传说 |名称|类型|偏向| |---|---|---| |泰罗克的传说|副手|元素| |泰罗克的面具|皮|增强| |泰罗克的羽毛|长柄|DPS| 奥金尼地穴 一切都会变好的 |名称|类型|偏向| |---|---|---| |奥金尼学者长跑|布|元素| |奥金尼僧侣外套|皮|增强| |奥金尼猎手外套|锁|增强| |主教护卫者|板|T| 暗影迷宫 卡拉赞的钥匙灵魂装置 |名称|类型|偏向| |---|---|---| |沙塔斯裹腕|布|元素| |间谍女王的护腕|皮|增强| |奥金尼护腕|锁|增强| |沙塔尔精炼臂甲|板|T|鲜血法典深入迷宫 |名称|类型|偏向| |---|---|---| |沙塔斯软靴|布|元素| |间谍女王的长靴|皮|增强| |奥金尼长靴|锁|恢复| |沙塔尔精炼护胫|板|近战|恶魔名册寻找间谍托古恩 法力陵墓 扫除竞争者 |名称|类型|偏向| |---|---|---| |哈拉迈德的三环护腿|皮|元素| |星界财团板甲护腿|板|N| |哈拉迈德的裹腿|布|恢复| |哈拉迈德的链甲护腿|锁|元素|安全第一别人的烂摊子 |名称|类型|偏向| |---|---|---| |星界财团裹布|披风|元素| |低温手套|皮|恢复| |星界财团相位衬肩|锁|增强| |血肉兽的金属胫甲|板|T|法力陵墓的静止间 H节点亲王沙塔尔的私人房间 H ","version":null,"tagName":"h3"},{"title":"盘牙湖泊​","type":1,"pageTitle":"外域副本任务奖励 联盟萨满视角","url":"/blog/2021/wow-sama#盘牙湖泊","content":"奴隶围栏 瓦斯琪的印记 团队卡达什圣杖 团队 幽暗沼泽 失踪的同伴 |名称|类型|偏向| |---|---|---| |塞纳里奥施法戒指|戒指|元素| |金藤护腕|布|恢复| |沼泽黑暗披风|披风|增强|我还要红色木槿我要红色木槿孢子叶黑色阔步者 |名称|类型|偏向| |---|---|---| |灌注精华的蘑菇|饰品|回血| |灌注能量的蘑菇|饰品|回蓝| 蒸汽地窟 督军的末日 |名称|类型|偏向| |---|---|---| |水术师头巾|布|元素| |利爪头盔|皮|增强| |大地守卫者的兜帽|锁|增强| |侍从的头饰|板|T|瓦斯琪的命令战争准备 ","version":null,"tagName":"h3"},{"title":"风暴要塞​","type":1,"pageTitle":"外域副本任务奖励 联盟萨满视角","url":"/blog/2021/wow-sama#风暴要塞","content":"生态船 夺回钥石 禁魔监狱 末日的预言者 |名称|类型|偏向| |---|---|---| |沙塔尔强能坠饰|项链|元素| |阿达尔的恢复项链|项链|恢复| |沙塔斯能量项链|项链|增强|如何杀入禁魔监狱 |名称|类型|偏向| |---|---|---| |沙塔尔学者披风|布|恢复| |阿达尔的礼物|布|元素| |纳鲁准确腰带|皮|增强| |沙塔斯勇士腰带|锁|增强| |沙塔尔守备官腰带|板|T|先知乌达鲁 能源舰 ","version":null,"tagName":"h3"},{"title":"时光之穴​","type":1,"pageTitle":"外域副本任务奖励 联盟萨满视角","url":"/blog/2021/wow-sama#时光之穴","content":"黑色沼择 (开启黑暗之门) 黑色沼泽开启黑暗之门 后续 |名称|类型|偏向| |---|---|---| |守护者指环|戒指|元素| |监护者的虔诚指环|戒指|恢复| |时间扭曲宝石|戒指|增强| |安多尔姆之泪|戒指|T|麦迪文的触摸 旧希尔斯布莱德丘陵 (逃离敦霍尔德) 往日的希尔斯布莱德塔雷莎的计谋逃离敦霍尔德 后续 |名称|类型|偏向| |---|---|---| |风暴之触|布|元素| |南海镇软鞋|皮|增强| |塔伦米尔防御者腰带|锁|恢复| |酋长的衬肩|板|T|好帽子 ","version":null,"tagName":"h3"},{"title":"fix 413 Payload too large","type":0,"sectionRef":"#","url":"/blog/2023/10月/413-payload-too-large","content":"施工中","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"小破站第一篇blog","type":0,"sectionRef":"#","url":"/blog/2023/10月/first-blog","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"为什么写 blog​","type":1,"pageTitle":"小破站第一篇blog","url":"/blog/2023/10月/first-blog#为什么写-blog","content":"大量的纸质笔记，查阅成本逐年升高。考虑将纸质笔记转移到互联网上，方便查阅。 ","version":null,"tagName":"h2"},{"title":"选择 blog​","type":1,"pageTitle":"小破站第一篇blog","url":"/blog/2023/10月/first-blog#选择-blog","content":"为什么不用现成的，例如： 印象笔记语雀掘金infoQCSDN博客园知乎 平台是助力，也是禁锢。希望我的文字，能让更多的人看到。 ","version":null,"tagName":"h2"},{"title":"GraphQL schema 基本概念","type":0,"sectionRef":"#","url":"/blog/2023/10月/graphql-schema-basics","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"TL;DR​","type":1,"pageTitle":"GraphQL schema 基本概念","url":"/blog/2023/10月/graphql-schema-basics#tldr","content":"Schema 是一种描述数据结构的方式，与数据实际存储的方式、结构和实现技术无关。 GraphQL uses a schema to describe the shape of data.The schema defines a hierarchy of types with field that are populated from data stores.The schema specifies exactly which queries and mutations are available for clients to excute. ","version":null,"tagName":"h2"},{"title":"翻译​","type":1,"pageTitle":"GraphQL schema 基本概念","url":"/blog/2023/10月/graphql-schema-basics#翻译","content":"GraphQL server 使用 schema 来描述数据结构。Schema 划分了 type 和 field 的层次结构，这些 field 通常是存储在后端数据库中的。Schema 还定义了客户端可以执行的 queries 和 mutations。 这篇文章介绍了 schema 的基本概念，以及如何创建一个 GraphQL server。 ","version":null,"tagName":"h2"},{"title":"Original docs​","type":1,"pageTitle":"GraphQL schema 基本概念","url":"/blog/2023/10月/graphql-schema-basics#original-docs","content":"Your GraphQL server uses a schema to describe the shape of your available data. This schema defines a hierarchy of types with fields that are populated from your back-end data stores. The schema also specifies exactly which queries and mutations are available for clients to execute. This article describes the fundamental building blocks of a schema and how to create one for your GraphQL server. ","version":null,"tagName":"h2"},{"title":"参考资料​","type":1,"pageTitle":"GraphQL schema 基本概念","url":"/blog/2023/10月/graphql-schema-basics#参考资料","content":"Apollo Server Docs ","version":null,"tagName":"h2"},{"title":"真的需要运动饮料么？","type":0,"sectionRef":"#","url":"/blog/2023/11月/运动饮料","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"起因​","type":1,"pageTitle":"真的需要运动饮料么？","url":"/blog/2023/11月/运动饮料#起因","content":"最近买了自行车通勤上下班，由于冬天穿的厚，每天出汗量增加，考虑要不要喝点脉动补补。无意间瞥了眼营养成分表，emmm。。。 ","version":null,"tagName":"h2"},{"title":"脉动的主要成分​","type":1,"pageTitle":"真的需要运动饮料么？","url":"/blog/2023/11月/运动饮料#脉动的主要成分","content":"维生素 C维生素 B6烟酸(烟酰酸) 一些占比，非常低，或者看起来非常低的营养素：热量、蛋白质、甜味物质、脂肪和碳水化合物。 ","version":null,"tagName":"h2"},{"title":"值的关注的问题​","type":1,"pageTitle":"真的需要运动饮料么？","url":"/blog/2023/11月/运动饮料#值的关注的问题","content":"合理膳食行动以及《中国居民膳食指南（2022）》中均推荐“人均每日添加糖摄入量不高于 25g”。 提倡不喝或少喝含糖饮料。 前面列出的营养素，都是运动饮料中的主要成分。但是，以青柠口味的脉动为例，碳水占比看起来只有有 2%（每 100ml）。 看起来，2% 的碳水，不是很多，甚至可以算少。但是，这里碳水的构成成分，是糖，并且只有糖。而且每 100ml 的含量达到了 4.8g。 以 2022 年的膳食指南推荐，人均摄入量，不应该高于 25g。如果喝一瓶 600ml 的脉动，这个数值就已经超出 15%了。 ","version":null,"tagName":"h2"},{"title":"不做二极管​","type":1,"pageTitle":"真的需要运动饮料么？","url":"/blog/2023/11月/运动饮料#不做二极管","content":"脉动所提供的维生素，是有价值的，但所含有的高糖分，也不能忽视。如果你的饮食已经足够健康，那么脉动的维生素，就是多余的。如果你的饮食不够健康，那么脉动的糖分，就是多余的。 根据国家体育总局的文章《运动后如何补水要问问运动量》,也是只有在大负荷（且 60 分钟以上）运动后，才可能需要运动饮料。 所以，平时还是少喝运动饮料吧。或者选择小包装，200/400ml 容量的。 ","version":null,"tagName":"h2"},{"title":"结论​","type":1,"pageTitle":"真的需要运动饮料么？","url":"/blog/2023/11月/运动饮料#结论","content":"为了顺利活着，有选择性的喝饮料。 ","version":null,"tagName":"h2"},{"title":"一些剁手前的分析","type":0,"sectionRef":"#","url":"/blog/2023/6月/buy","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"显示器​","type":1,"pageTitle":"一些剁手前的分析","url":"/blog/2023/6月/buy#显示器","content":"42、4k 可以接受 因为用U2422HX纵向使用, 发现看 log、shell 真爽 根据 U2422HX 的尺寸 53.6x36.4, 再结合 LG C3 的尺寸, 93.2x57.7. 尺寸可以接受 唯一需要考虑的, 就是桌子的深度. 60 有些勉强, 因为需要考虑显示器支架的深度. 所以, 80 是比较合理的一个预想值 标准: 4k42 英寸桌子&gt;60cm 的深度 目前可用的选项 LG C3 42ROG PG42UQ ","version":null,"tagName":"h2"},{"title":"iPad -> M 芯片的 mini / pro 11​","type":1,"pageTitle":"一些剁手前的分析","url":"/blog/2023/6月/buy#ipad---m-芯片的-mini--pro-11","content":"12.9、11、air、mini、ipad 10、ipad 9: ","version":null,"tagName":"h2"},{"title":"CPU​","type":1,"pageTitle":"一些剁手前的分析","url":"/blog/2023/6月/buy#cpu","content":"pro、air、mini、iPad, 依次递减一个代系的 CPU M2、M1、A15、A14、A13 ","version":null,"tagName":"h3"},{"title":"屏幕​","type":1,"pageTitle":"一些剁手前的分析","url":"/blog/2023/6月/buy#屏幕","content":"12.9 &gt; 11 &gt; 10.5​ 12.9 相比 11, XDR 和尺寸. 但没什么必要. 太大了, 反而不如直接上 MBP 了. 虽然 ipad 看起来方便, 但是系统并没那么方便10.5 和这俩相比, 就分辨率低了点, cpu 啥的硬件老了点, 别的区别不大 显示效果, 应该差距就还好所以, 显示效果, 依旧标杆. 不用为了显示效果去换 ipad Air、mini​ 刀法也够精准的... promotion 都砍一刀、mini 的 cpu 再砍一刀...服了 iPad​ 屏幕素质又砍了一刀, 没有 P3 广色域了... 抗反射涂层也没了 ","version":null,"tagName":"h3"},{"title":"键盘​","type":1,"pageTitle":"一些剁手前的分析","url":"/blog/2023/6月/buy#键盘","content":"不需要了. 没有用 ipad pro 或者 ipad mini 写代码的需求. 真要有, filco 和后买的这个红轴, 蓝牙都能用. 出差? 你出差用 ipad 干活么? 肯定带着 mbp 啊. 怎么会用 ipad 写代码... ","version":null,"tagName":"h3"},{"title":"笔​","type":1,"pageTitle":"一些剁手前的分析","url":"/blog/2023/6月/buy#笔","content":"二代的笔可以磁吸了, 倒是可以考虑下. 看 pdf? 或许吧 所以啊. 不特意给老妈买 ipad 了. 我买旗舰, 老大用个二手旗舰吧还是 ipad mini 的尺寸, 确实更适合偶尔看看. ipad pro, 还是大了点. 人啊, 总想用更小的体积, 却能得到更大的视野. 看起来, 只有 vision pro 能做到 Air2、10.5 如果不出问题, 就不换了. 真出了问题, 再考虑换吧. 到时候, 再去费这个心吧. 希望后边, 能有 M 芯片的 mini ","version":null,"tagName":"h3"},{"title":"GraphQL schema 命名习惯","type":0,"sectionRef":"#","url":"/blog/2023/10月/naming-conventions","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"TL;DR​","type":1,"pageTitle":"GraphQL schema 命名习惯","url":"/blog/2023/10月/naming-conventions#tldr","content":"GraphQL 规范并没有强制要求命名规范，但建议遵循以下规则： Field names: camelCaseEnum values: ALL_CAPSType names: PascalCaseEnum names: PascalCase ","version":null,"tagName":"h2"},{"title":"翻译​","type":1,"pageTitle":"GraphQL schema 命名习惯","url":"/blog/2023/10月/naming-conventions#翻译","content":"GraphQL 规范没有强制要求命名规范。不过，建立命名规范有助于确保一致性。我们建议使用以下约定： 字段名称：camelCase。许多 GraphQL 客户端是用 JavaScript、Java、Kotlin 或者 Swift 开发的，这些语言中，变量通常使用驼峰命名法。枚举值：ALL_CAPS。枚举值和常量比较相似。类型名称：PascalCase。JavaScript 等语言，类名通常使用帕斯卡命名法。枚举名称：PascalCase。 ","version":null,"tagName":"h2"},{"title":"Original docs​","type":1,"pageTitle":"GraphQL schema 命名习惯","url":"/blog/2023/10月/naming-conventions#original-docs","content":"The GraphQL specification is flexible and doesn't impose specific naming guidelines. However, it's helpful to establish a set of conventions to ensure consistency across your organization. We recommend the following: Field names should use camelCase. Many GraphQL clients are written in JavaScript, Java, Kotlin, or Swift, all of which recommend camelCase for variable names.Type names should use PascalCase. This matches how classes are defined in the languages mentioned above.Enum names should use PascalCase.Enum values should use ALL_CAPS, because they are similar to constants. These conventions help ensure that most clients don't need to define extra logic to transform the results returned by your server. ","version":null,"tagName":"h2"},{"title":"参考资料​","type":1,"pageTitle":"GraphQL schema 命名习惯","url":"/blog/2023/10月/naming-conventions#参考资料","content":"Apollo Server DocsGraphQL Spec ","version":null,"tagName":"h2"},{"title":"作为「码农」的第一个十年","type":0,"sectionRef":"#","url":"/blog/2023/6月/first-ten-years","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"十年​","type":1,"pageTitle":"作为「码农」的第一个十年","url":"/blog/2023/6月/first-ten-years#十年","content":"如果从上大学, 闭门造车似地捣鼓 ActionScript3 开始, 已经写了 10 年代码了. AS3Java、Struts2、Hibernate、HTML、Javascript、CSS、SVN、Git、SQL Server、MySQL、AndroidLinux、PHP、ThinkPHP、Cavy、SQLite、Angular1.x、Python、Django、Postgres、Vue2、Webpack、Hive、Docker、Go、GraphQL、Flutter、WebAssemblyReact、Typescript、Node.jsRust 这期间, 从懵懂的 209, 到融洽的 NF、破碎的 IPS、耄耋的 ATH, 再到 reroll 的 COSMOS, 摸了五花八门的技术, 可没有一项是真正深入的. 最可惜的是, 想明白这个事情, 是十年的末尾. 万幸的也是, 十年的末尾, 我终于想明白点很简单的事情, 算是摸到了「程序员」的边吧. ","version":null,"tagName":"h2"},{"title":"答卷​","type":1,"pageTitle":"作为「码农」的第一个十年","url":"/blog/2023/6月/first-ten-years#答卷","content":"就工资来讲, 第一个「十年」拖了国家、人均百万的后腿. 算是糊口的状态, 饿不着自己 从个人成长来讲, 连 60 分也够不上. 广度好像有了, 可深度完全没有, 连个水坑都算不上...直到最近两年, 才有点开悟的迹象. 摆烂太久, 上帝会拿走你的天赋 这是今年才想明白的事情. 所以, 写一写字, 动一动脑子. 不求挽回, 但求保存下残留的火 ","version":null,"tagName":"h2"},{"title":"时间都去哪了?​","type":1,"pageTitle":"作为「码农」的第一个十年","url":"/blog/2023/6月/first-ten-years#时间都去哪了","content":"10 年光阴, 为什么没能成为 10000 小时的研发大佬? 除了搬砖, 我到底都干了些啥? 魔兽世界、FGO、王者荣耀、刺激战场、PS5动画片、日剧、电影、小说 从大学开始, 就重度动画片爱好者. 因为现实里的人, 很难演出幻想中的效果. 魔兽世界, 也是时断时续, 一直在玩. 终于, 去年年底, 算是彻底断了这个念想, 永久 AFK 了. 王者荣耀, 上班后才接触, 消耗时间的大户, 曾几度卸载. 但每次看到 KPL 时, 还是向往 5 个人一起为了夺冠而努力的团队氛围, 忍不住下载下来, 打上两把. 阻止自己成为 10000 小时先生的, 大概率不是外在环境. 而是自己的怠惰, 战胜了对未来的向往. 这一点, 也在慢慢调整, 等稍有成效后, 另开一文吧 ","version":null,"tagName":"h2"},{"title":"这个系列, 想写点什么?​","type":1,"pageTitle":"作为「码农」的第一个十年","url":"/blog/2023/6月/first-ten-years#这个系列-想写点什么","content":"最近准备从做事方向的树立方法、作为「开发者」基本素养的培养、基本功的夯实几个方面, 进行一个为期三年的计划. 为下一个「十年」重构一套足够夯实、稳定的地基. 在公众号开一个坑, 「第二个『十年』」期间, 会总结并输出自己对读书、视频课或 code 等方面的思考、感悟与畅想(瞎琢磨). 希望能让下一个「十年」达到 85 分. 并争取将赛道切换到「开发者」而不是再搬十年的 🧱 也希望可以把这样的状态, 保持下去. 也希望自己在「开发者」的路上能有第一个、第二个, 甚至更多个「十年」 共勉 ","version":null,"tagName":"h2"},{"title":"Introspection 是个啥","type":0,"sectionRef":"#","url":"/blog/2023/11月/apollo-introspection","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"是个啥​","type":1,"pageTitle":"Introspection 是个啥","url":"/blog/2023/11月/apollo-introspection#是个啥","content":"在 GraphQL 中，&quot;introspection&quot;是一种机制，它允许客户端查询 GraphQL server 的模式（schema）。通过 introspection，客户端可以知道服务器支持哪些类型、字段、查询和变更等。 当你在 Apollo Server 的构造函数中设置introspection: true时，你就启用了 introspection。这意味着客户端可以发送 introspection 查询来获取你的 GraphQL 模式的详细信息。 这在开发和测试环境中非常有用，因为它可以帮助你理解和调试你的 GraphQL API。然而，在生产环境中，出于安全考虑，你可能想要禁用 introspection，以防止未经授权的客户端获取你的模式的详细信息。 ","version":null,"tagName":"h2"},{"title":"如何使用​","type":1,"pageTitle":"Introspection 是个啥","url":"/blog/2023/11月/apollo-introspection#如何使用","content":"在 GraphQL 中，你可以使用特殊的系统查询__schema和__type来进行 introspection 查询。以下是一些基本的 introspection 查询示例： 查询模式中所有类型的名字： query { __schema { types { name } } }  查询特定类型的详细信息： query { # 请将`YourTypeName`替换为你想查询的类型的名字。 __type(name: &quot;YourTypeName&quot;) { name fields { name type { name kind } } } }  查询 schema 中所有 query 的名字： query { __schema { queryType { fields { name } } } }  这些 query 可以在任何 GraphQL client 中运行，例如 Apollo Client 或者 GraphQL Playground。只要你的 GraphQL server 启用了 introspection，这些 query 就可以工作。 ","version":null,"tagName":"h2"},{"title":"前端视角的可观测性(一)","type":0,"sectionRef":"#","url":"/blog/2023/7月/observability-frontend-1","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"前言​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#前言","content":"最近，我所在的产品组，将完善监控系统，放入了版本规划中。 趁此良机，了解了一波可观测性相关的背景和技术。 同时，对原有的监控方式，进行了一定的改造。 ","version":null,"tagName":"h2"},{"title":"可观测性​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#可观测性","content":"控制理论中的可观察性（observability）是指系统可以由其外部输出推断其其内部状态的程度。系统的可观察性和可控制性是数学上对偶的概念。可观察性最早是匈牙利裔工程师鲁道夫·卡尔曼针对线性动态系统提出的概念[1][2]。若以信号流图来看，若所有的内部状态都可以输出到输出信号，此系统即有可观察性。 ","version":null,"tagName":"h2"},{"title":"什么是可观测性？​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#什么是可观测性","content":"可观测性是指能够通过检查系统或应用的输出、日志和性能指标来监控、测量和理解系统或应用的状态。 讲人话，我理解就是将传统监控系统的日志，进行了标准化、体系化。同时，将原来“孤岛式”的日志进行了“关联”。将所有日志组合成整体，以此来分析系统状态。 ","version":null,"tagName":"h3"},{"title":"为什么会出现？或者说，为什么现在火了？​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#为什么会出现或者说为什么现在火了","content":"监控系统并不是什么稀罕事务，但为什么之前没有什么热度呢？ 我认为，是排查问题的门槛，变高了。变高的原因，主要有 2 方面： 系统复杂度数据量 系统复杂度​ 首先，是系统的复杂度在不断上升。单机软件、集群部署、云服务、虚拟化。 软件部署方式的每一次升级，都在提升软件系统的整体能力。 与此同时，一旦出现问题，排查&amp;解决问题的难度，也在不断上升。如果身边有运维同学，可以听他们讲一讲，独属于他们的、深夜里的故事 🤣 数据量​ 从计算机诞生，我们已经经历了单机软件、局域网、互联网，且身处移动互联网。 在网络高度普及的今天，软件和服务，包裹着每一个网民。网络触手的延伸，在提供了高度便利的同时，也给数据量带来了井喷式的增长。这给问题排查，增加了不小的难度。 当下，我们身处移动互联网的上半场，当摄像头、家用电器、车载系统和新基建中无处不在的传感器入网后，在移动互联网的下半场（IoT），数据量的暴增，是可以预见的。 所以，传统监控系统相对片面、局部的监控指标，无法满足复杂环境下的系统状态监控、问题排查和系统调优。 ","version":null,"tagName":"h3"},{"title":"怎么用？​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#怎么用","content":"Opentelemetry、Prometheus、Grafana、Jaeger 等等。现在已经有很多成熟的开源工具可供集成、或二次定制开发。也有不少收费的平台，方便使用。 通过这些可观测性工具，可以 更加全面的监控系统指标更清晰的分析调用链条更准确、更有把握的的优化系统瓶颈点 这些不是空口白话，我们产品在初步集成 Jaeger 后，已经发现了几处有价值的隐藏问题。这在原来，只能通过大规模的压力测试（如果有）、客户现场反馈来发现、修复。 后边有机会（如果不鸽），会分享一些脱敏的相关实践。 ","version":null,"tagName":"h3"},{"title":"一点想法​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#一点想法","content":"这周，集成进系统的 Jaeger 基本可用了。通过和后端师傅的交流，发现了几处隐藏的问题，挺开心的。 虽然有些马后炮了，但在毕业不久的时候，就有对完善的监控体系的期待了。可惜，当时虽然有考虑过监控系统的雏形，但只停留在想象中了。现实里的时间，都去打游戏了。。。 总之，Observability相关的技术, 不是颠覆传统监控系统的银弹。 在我看来，更像是应运而生。是对传统监控体系的完善、补充和升级。 ","version":null,"tagName":"h2"},{"title":"参考资料​","type":1,"pageTitle":"前端视角的可观测性(一)","url":"/blog/2023/7月/observability-frontend-1#参考资料","content":"wikiRedHat ","version":null,"tagName":"h2"},{"title":"JS Set为什么是带键的集合?","type":0,"sectionRef":"#","url":"/blog/2023/6月/keyed-collection","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"起因​","type":1,"pageTitle":"JS Set为什么是带键的集合?","url":"/blog/2023/6月/keyed-collection#起因","content":"为了降低并发时的 API 请求量, 这两天写了个 LRU Cache. 其中用到了 Set 做 AllowList, 来判断 API 是否应该被缓存. 在 MDN 查 API 时, 发现 Set 被归类在 Keyed Collection 中. 一直以来, 下意识觉得 Set 只是 value 唯一的 Array. 应该属于 Indexed Collection. 感觉有些奇怪, 所以就查了下 Set 的实现机制 ","version":null,"tagName":"h2"},{"title":"过程​","type":1,"pageTitle":"JS Set为什么是带键的集合?","url":"/blog/2023/6月/keyed-collection#过程","content":"一开始, 先去 MDN 查的文档, 只说了属于 Keyed Collection, 但没细说为什么. 又去 ecma-international.org, 查 ECMA 标准, 结果也没有明确说明, 为什么 Set 属于 Keyed Collection. 我一开始还觉得是文档写得不够详细, 后来发现是自己太菜了 😂 简单思考了下, 没想通. 就使用魔法武器了. 虽然有点前后不一, 但 copilot 提供了最关键的信息: Hash Table. 下边是 copilot 的回答 在 JavaScript 中，Set 是一种基于哈希表实现的数据结构，用于存储一组唯一的值。Set 属于 ECMAScript 6 中新增的数据类型之一，被归类为 Keyed Collection 类型。 Keyed Collection 是 ECMAScript 6 中新增的一种数据类型，用于存储一组键值对。除了 Set 之外，还包括 Map 和 WeakMap。这些数据类型都具有以下特点： 可以使用任意类型的值作为键。可以使用 for...of 循环遍历键值对。可以使用 size 属性获取键值对的数量。 Set 作为 Keyed Collection 的一种，可以使用任意类型的值作为元素，而且每个元素都是唯一的。因此，Set 可以用于实现集合、过滤重复值等功能。 需要注意的是，Set 和 Map 的实现方式不同，虽然它们都属于 Keyed Collection 类型。Map 是一种键值对的集合，其中每个键都是唯一的，可以使用键来访问对应的值。Set 是一种值的集合，其中每个值都是唯一的，可以使用值来访问对应的值。 再然后, 就破案了... 因为 Hash Table 中, 每个元素都有唯一的 key, 用 key 来访问对应的值. 所以, Set 相当于一个 key-value 相同的、特殊的 Hash Table, 我认为也可以理解为, 一种 key-value 一致、特殊的 Map ","version":null,"tagName":"h2"},{"title":"结论​","type":1,"pageTitle":"JS Set为什么是带键的集合?","url":"/blog/2023/6月/keyed-collection#结论","content":"Set 是基于 Hash Table 实现的「值的集合」由于 Hash Table 的 key-value 特性, Set 的 key-value 相同Set 相当于一种特殊的 Map 所以, Set 属于 Keyed Collection  ┌─────┐ ┌─▶│Array│ ┌──────────────────┐ │ └─────┘ ┌─▶│Indexed Collection│──┤ │ └──────────────────┘ │ ┌───────────┐ │ └─▶│Typed Array│ │ └───────────┘ ┌────────────┐ │ │ Collection │──┤ ┌───┐ * └────────────┘ │ ┌─▶│Map│ * │ │ └───┘ * │ │ ┌───────┐ * │ ┌──────────────────┐ ├─▶│WeakMap│ * ┌───────────────────┐ └─▶│ Keyed Collection │──┤ └───────┘ * │Based on Hash Table│ └──────────────────┘ │ ┌───┐ * └───────────────────┘ ├─▶│Set│ * │ └───┘ * │ ┌───────┐ * └─▶│WeakSet│ * └───────┘ *  ","version":null,"tagName":"h2"},{"title":"资料​","type":1,"pageTitle":"JS Set为什么是带键的集合?","url":"/blog/2023/6月/keyed-collection#资料","content":"https://262.ecma-international.org/13.0/#sec-keyed-collectionshttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#key_and_value_equality_of_map_and_set ","version":null,"tagName":"h2"},{"title":"TS Array.reduce没有与此调用匹配的重载?","type":0,"sectionRef":"#","url":"/blog/2023/6月/TS-Array-reduce-error","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"起因​","type":1,"pageTitle":"TS Array.reduce没有与此调用匹配的重载?","url":"/blog/2023/6月/TS-Array-reduce-error#起因","content":"一个 feature 开发, 结果需求评审、工时预估, 简直是事故级别的. 最后, 迫于无奈, 全组人都得上去救火... 今天, 帮忙改 bug 的时候, 发现新 checkout 下来的代码, 还带着新鲜的语法错误...简直大无语. 翻了遍代码, 发现很多地方都存在 Array.reduce 类型重载相关的问题, 简单记录一下解决过程. ","version":null,"tagName":"h2"},{"title":"排查过程​","type":1,"pageTitle":"TS Array.reduce没有与此调用匹配的重载?","url":"/blog/2023/6月/TS-Array-reduce-error#排查过程","content":"大家的 vscode 都不装语法提示插件么? 代码挂着红线, 就扔代码库了??? 抽时间, 得把 hook 安排上了 🙄 // 业务代码不方便外流, 简单写了个demo, 问题原因相同 const nums = [1, 2, 3, 4, 5]; const sum = nums.reduce((pre, cur) =&gt; { return [...pre, { count: cur }]; }, []); sum.push({ count: 6 }); console.log(sum); // 这段代码, 编译成.js后, 其实是可以运行的. 但如果装了插件, 可以看到明显的TS语法错误.. // 输出值 // [ // { count: 0 }, // { count: 1 }, // { count: 2 }, // { count: 3 }, // { count: 4 }, // { count: 5 }, // { count: 6 } // ]  (pre, cur)=&gt;{} 会提示没有对应的重载类型. 原因不复杂, 就是类型不符合推导预期, 但为什么不符合预期, 还真没仔细看过. 本着 fixbug 可以, 但不能一无所获的思想, 查看了对应的 TS 类型声明 // 3种reduce的类型声明 reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T): T; reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue: T): T; reduce&lt;U&gt;(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, array: T[]) =&gt; U, initialValue: U): U;  很明显, reduce 对类型的推导, 基本就是, 「参数类型」和「返回值类型」相同、且 reduce 前后, 只有一种类型, 那不用加「泛型」 但是, 如果出现1 种以上的类型, 且 preValue 与 initValue、returnType 类型不同, 就必须显式标注类型. 案例中, pre 的类型为never[], cur 的类型是number, 而 reduce 的返回值类型是Array&lt;{ count: number }&gt;. 根据之前推导的结论, 出现 3 种类型, 且 pre 与 cur、return 值类型不同, 必须显式声明类型. 根据 TS 的类型声明, 有 2 种可用的解决方法: 给 initValue 增加类型断言, [] as Array&lt;{ count: number }&gt;.在 reduce 处, 声明泛型类型nums.reduce&lt;Array&lt;{ count: number }&gt;&gt; 核心解决思路: 减少 TSC 推导类型的种类, 促使其符合已存在的类型定义. ","version":null,"tagName":"h2"},{"title":"吐槽​","type":1,"pageTitle":"TS Array.reduce没有与此调用匹配的重载?","url":"/blog/2023/6月/TS-Array-reduce-error#吐槽","content":"只要思想不滑坡, 办法总比困难多 问题很直观, 也不复杂. 但看 log, 这语法问题已经存在 2 个月了, 真的是 vscode 没装插件么? ","version":null,"tagName":"h2"},{"title":"前端视角的可观测性(二)","type":0,"sectionRef":"#","url":"/blog/2023/7月/observability-frontend-2","content":"高估自己了，opentelemetry 还差不少。沉淀一下，再写这种系列式的文章吧。","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"GraphQL插件踩坑","type":0,"sectionRef":"#","url":"/blog/2023/7月/vscode-extension-graphql","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"背景​","type":1,"pageTitle":"GraphQL插件踩坑","url":"/blog/2023/7月/vscode-extension-graphql#背景","content":"之前用的 GraphQL 插件, 只开启了语法高亮. 自己写的 schema 没什么问题, 排查问题时, 只能靠搜索, 太难了.... vscode 有不少语法提示插件, 但很多不太适用了. 试用了几款, 踩了踩坑... ","version":null,"tagName":"h2"},{"title":"插件​","type":1,"pageTitle":"GraphQL插件踩坑","url":"/blog/2023/7月/vscode-extension-graphql#插件","content":"","version":null,"tagName":"h2"},{"title":"GraphQL: Language Feature Support​","type":1,"pageTitle":"GraphQL插件踩坑","url":"/blog/2023/7月/vscode-extension-graphql#graphql-language-feature-support","content":"# graphql.config.yml //in root directory # 使用URL的方式, 只有语法提示, 没有定义跳转 # schema: http://localhost:5910/graphql schema: - ./bff/src/schemas/*.gql - ./bff/src/schemas/**/*.gql - ./bff/src/schemas/**/**/*.gql  需要按照 graphql-config 的格式, 添加配置文件有语法提示、支持定义跳转目前仍在维护唯一可惜的是, 没有引用查询 有常规的语法提示了, 而且自定义类型也可以提示. 支持定义跳转 ","version":null,"tagName":"h3"},{"title":"vscode-graphql​","type":1,"pageTitle":"GraphQL插件踩坑","url":"/blog/2023/7月/vscode-extension-graphql#vscode-graphql","content":"个人开发者插件, 坚持与否, 全看心情上一次的发布时间, 在 2019 年... 验证了第一条插件代码库 (iemmp.com) 已经丢失了.......按照 quick start 配置 有高亮, 但是不太符合预期有语法提示没有定义跳转 整体效果不是很理想, 故放弃 ","version":null,"tagName":"h3"},{"title":"Apollo GraphQL​","type":1,"pageTitle":"GraphQL插件踩坑","url":"/blog/2023/7月/vscode-extension-graphql#apollo-graphql","content":"// module.exports = { // client: { // service: { // name: &quot;my-service-name&quot;, // localSchemaFile: &quot;./src/schemas/*.graphql&quot;, // }, // }, // }; // module.exports = { // client: { // service: { // name: &quot;github&quot;, // url: &quot;http://localhost:5910/graphql&quot;, // // optional headers // headers: { // authorization: &quot;Bearer lkjfalkfjadkfjeopknavadf&quot;, // }, // // optional disable SSL validation check // skipSSLValidation: true, // }, // }, // }; module.exports = { service: { endpoint: { url: &quot;http://localhost:5910/graphql&quot;, headers: { // optional authorization: &quot;Bearer lkjfalkfjadkfjeopknavadf&quot;, }, skipSSLValidation: true, // optional, disables SSL validation check }, }, }; // export default { // service: { // endpoint: { // url: &quot;http://localhost:5910/graphql&quot;, // headers: { // // optional // authorization: &quot;Bearer lkjfalkfjadkfjeopknavadf&quot;, // }, // skipSSLValidation: true, // optional, disables SSL validation check // }, // }, // };  不支持 es module更新时间还在 22 年issue 关闭速度相当一般... 搞了半天, 只有语法高亮, 没有定义跳转... 也可能是我太菜了 😭 配置文件加载总是不成功. .js 因为 es module 不能用, .cjs 加载不上... 评论区也有吐槽配置不生效的, 不折腾了... ","version":null,"tagName":"h3"},{"title":"几种验证端口开启的方法","type":0,"sectionRef":"#","url":"/blog/2023/7月/port-tool","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":null},{"title":"背景​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#背景","content":"网络相关的记忆, 都就着饭吃到肚子里了 🙄 今天需要验证服务器端口是否可以连通, 找到了几种方法, 简单记录一下 ","version":null,"tagName":"h2"},{"title":"telnet​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#telnet","content":"telnet 命令是一个用于测试网络连接的工具，可以模拟客户端与服务器之间的连接，以检查服务器端口是否可以正常连接。telnet 命令最初是由美国计算机科学家 Simon S. Lam 开发的，用于在 UNIX 系统上测试网络连接。后来，telnet 命令被广泛应用于各种操作系统和网络设备中，成为了一种通用的网络测试工具。 telnet 命令可以通过终端或命令行界面使用，可以连接到任何支持 TCP 或 UDP 协议的服务器，以测试服务器端口是否可以正常连接。telnet 命令可以模拟客户端与服务器之间的连接，可以发送和接收数据，以检查服务器的响应是否正常。telnet 命令通常用于测试 Web 服务器、邮件服务器、FTP 服务器等等，以确保这些服务器可以正常工作。 ","version":null,"tagName":"h2"},{"title":"安装​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#安装","content":"macOS M1​ brew install telnet  ","version":null,"tagName":"h3"},{"title":"使用​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#使用","content":"打开 terminal输入命令telnet server port. Eg: telnet localhost 5910敲回车如果出现下方格式的内容, 证明相应的服务、端口可以连通 Trying ::1... Connected to localhost. Escape character is '^]'.  按下ctrl + ], 再输入quit, 回车. 即可退出 telnet 命令 ","version":null,"tagName":"h3"},{"title":"netcat(nc)​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#netcatnc","content":"nc 命令是一个用于测试网络连接的工具，也称为 netcat。它可以用于创建 TCP 或 UDP 连接，发送和接收数据，以及监听端口等操作。nc 命令最初是由开发者 Hobbit 开发的，后来被其他开发者维护和扩展，成为了一个通用的网络工具。 nc 命令是开源的，可以在 GitHub 上找到相关的源代码。nc 命令的源代码托管在多个仓库中，其中一些仓库包含了不同版本的 nc 命令实现 ","version":null,"tagName":"h2"},{"title":"安装​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#安装-1","content":"macOS 13.4 自带 nc, 无需安装 ","version":null,"tagName":"h3"},{"title":"使用​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#使用-1","content":"打开 terminal输入nc -zv localhost 5910, 敲回车如果出现如下格式的信息, 证明连接成功 Connection to localhost port 5910 [tcp/*] succeeded!  如果出现如下格式的信息, 则连接失败 nc: connectx to localhost port 5911 (tcp) failed: Connection refused  ","version":null,"tagName":"h3"},{"title":"常用参数​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#常用参数","content":"-zv 参数表示在扫描端口时，不发送数据，只显示详细信息。-z 参数表示只扫描端口，不发送数据，-v 参数表示显示详细信息。因此，-zv 参数的含义是只扫描端口，并显示详细信息，但不发送数据。这个参数通常用于快速检查服务器端口是否开启。 -l：监听模式，用于在指定端口上监听连接请求。-p：指定端口号。-u：使用 UDP 协议。-w：设置超时时间。-z：只扫描端口，不发送数据。-v：显示详细信息。 ","version":null,"tagName":"h3"},{"title":"nmap​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#nmap","content":"nmap 命令是一个用于网络探测和安全审计的工具，可以用于扫描主机和端口，识别操作系统和服务等。nmap 命令最初是由开发者 Fyodor（Gordon Lyon）开发的，后来被其他开发者维护和扩展，成为了一个通用的网络工具。 nmap 命令是开源的，您可以在 GitHub 上找到相关的源代码。nmap 命令的源代码托管在官方的 Git 仓库中，您可以通过以下链接访问： [https://github.com/nmap/nmap](vscode-file://vscode-app/Applications/Visual Studio Code - Insiders.app/Contents/Resources/app/out/vs/code/electron-sandbox/workbench/workbench.html) ","version":null,"tagName":"h2"},{"title":"安装​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#安装-2","content":"macOS M1​ brew install nmap  ","version":null,"tagName":"h3"},{"title":"使用​","type":1,"pageTitle":"几种验证端口开启的方法","url":"/blog/2023/7月/port-tool#使用-2","content":"扫描常用端口​ 打开 terminal输入nmap localhost, 敲回车显示结果(默认只扫描常用的 1000 个端口) Starting Nmap 7.94 ( https://nmap.org ) at 2023-07-19 11:04 CST Nmap scan report for localhost (127.0.0.1) Host is up (0.000047s latency). Other addresses for localhost (not scanned): ::1 Not shown: 995 closed tcp ports (conn-refused) PORT STATE SERVICE 5910/tcp open cm 8080/tcp open http-proxy Nmap done: 1 IP address (1 host up) scanned in 0.04 seconds  扫描指定端口​ 打开 terminal输入nmap -p 5910 localhost, 敲回车显示结果 Starting Nmap 7.94 ( https://nmap.org ) at 2023-07-19 11:18 CST Nmap scan report for localhost (127.0.0.1) Host is up (0.00023s latency). Other addresses for localhost (not scanned): ::1 PORT STATE SERVICE 5910/tcp open cm Nmap done: 1 IP address (1 host up) scanned in 0.02 seconds  ","version":null,"tagName":"h3"},{"title":"关于我","type":0,"sectionRef":"#","url":"/blog/docs/about-me","content":"关于我 一个特别能睡的吃货。 一个刀耕火种的程序猿。 一个希望成为开发者的菜鸟。","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"Directives","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Defining a Schema/directives","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"有效位置​","type":1,"pageTitle":"Directives","url":"/blog/docs/Apollo Server/Defining a Schema/directives#有效位置","content":"每个 directive 在 GraphQL scheme 或 operation 中，只能出现在规定的位置。这些位置在 directive 定义处列出。 举个例子，这里是 GraphQL 规范的 @deprecateddirective 定义： directive @deprecated( reason: String = &quot;No longer supported&quot; ) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE  这个例子表明@deprecated可以修饰列出的四个位置中的任何一个。也要注意reason参数是可选的并且提供了默认值。每一个位置的示例如下： # ARGUMENT_DEFINITION # Note: @deprecated arguments _must_ be optional. directive @withDeprecatedArgs( deprecatedArg: String @deprecated(reason: &quot;Use `newArg`&quot;) newArg: String ) on FIELD type MyType { # ARGUMENT_DEFINITION (alternate example on a field's args) fieldWithDeprecatedArgs(name: String @deprecated): String # FIELD_DEFINITION deprecatedField: String @deprecated } enum MyEnum { # ENUM_VALUE OLD_VALUE @deprecated(reason: &quot;Use `NEW_VALUE`.&quot;) NEW_VALUE } input SomeInputType { nonDeprecated: String # INPUT_FIELD_DEFINITION deprecated: String @deprecated }  如果@deprecated出现在 GraphQL 文档的其他位置，将产生一个错误。 如果创建 custom directive，需要在 schema 中定义它(还有它可以使用的位置)。不需要定义像@deprecated这类的默认 directive。 ","version":"Next","tagName":"h2"},{"title":"schema directive 对比 operation directive​","type":1,"pageTitle":"Directives","url":"/blog/docs/Apollo Server/Defining a Schema/directives#schema-directive-对比-operation-directive","content":"通常，directive 只出现在 GraphQL schema 或 GraphQL operation 中(很少同时出现，尽管规范允许这种情况)。 举个例子，所有的默认 directive，@deprecated是只能在 schema 使用的 directive，而@skip和@include只能在 operation 中使用。 GraphQL 规范列出了 directive 所有可能出现的位置。schema 位置在TypeSystemDirectiveLocation列出，而 operation 位置在ExecutableDirectiveLocation中列出。 ","version":"Next","tagName":"h3"},{"title":"默认 directive​","type":1,"pageTitle":"Directives","url":"/blog/docs/Apollo Server/Defining a Schema/directives#默认-directive","content":"GraphQL 规范定义了以下的默认 directive： DIRECTIVE\t描述@deprecated(reason: String)\t将字段或枚举值的 schema 定义标记为不推荐使用，理由是可选项。 @skip(if: Boolean!)\t如果true，operation 中被修饰的字段或片段不会被 GraphQL server 解析。 @include(if: Boolean!)\t如果false，operation 中被修饰的字段或片段不会被 GraphQL server 解析。 ","version":"Next","tagName":"h2"},{"title":"custom directive​","type":1,"pageTitle":"Directives","url":"/blog/docs/Apollo Server/Defining a Schema/directives#custom-directive","content":"Apollo Server 不为改变 schema 的 custom directive 提供内置支持。 私货：这意味着如果想用，需要自己开发 schema 能够定义修饰 schema 其他部分的 custom directive： # Definition directive @uppercase on FIELD_DEFINITION type Query { # Usage hello: String @uppercase }  在将 schema 传递给 Apollo Server 之前，如果想定义一个 custom directive 去改变 schema 的执行逻辑，建议使用@graphql-tools库。可以参考example of using a custom directive to transform a schema ","version":"Next","tagName":"h2"},{"title":"In subgraphs​","type":1,"pageTitle":"Directives","url":"/blog/docs/Apollo Server/Defining a Schema/directives#in-subgraphs","content":"在 federated graph 中使用 custom directvie 之前，务必思考以下几点： 如果多个 subgraph 可以解析一个特定字段，每个 subgraph 几乎都应该对该字段使用(定义完全相同)的 custom directive。否则，这个字段的行为可能取决于哪一个 subgraph 来解析它。因为 directive 是特定于各个 subgraph 的，不同的 subgraph 使用不同的逻辑定义相同的 directive，在技术上是可行的。如前一点所述，如果 custom directive 被用于过个 subgraph 去解析特定的字段，则应该在 subgraph 中给同一 directive 定义相同的逻辑。Composition不会检测或警告这种不一致。 私货：compostion 该怎么翻译？组合各个 subgraph schema 的过程？ 组合过程以不同方式对待可执行(客户端侧)的和类型系统(服务器侧)的命令： 在以下情况，可执行 directive 被组合到 supergraph 中： 所有 subgraph 定义了相同的 directivedirective 没有被包含在任何@composeDirectivedirective 中 类型系统 directive 不会被包含到 supergraph 的 schema 中，但是它们通过@composeDirectivedirective 可以提供信息给路由 Transformer function​ 如我们的例子所示，在 Apollo Server 3 和 4 中，可以给每一个 subgraph schema 的 custom directive 定义 transformer 函数 为了将 transformer 函数应用到可执行 subgraph schema，通常要先使用buildSubgraphSchema生成 subgraph schema： let subgraphSchema = buildSubgraphSchema({ typeDefs, resolvers });  并非直接将结果传递给ApolloServer构造函数，首先应用所有的 transformer 函数到它： // Transformer function for an @upper directive subgraphSchema = upperDirectiveTransformer(subgraphSchema, &quot;upper&quot;);  应用所有 transformer 函数后，通常提供最终的 subgraph schema 给ApolloServer构造函数： const server = new ApolloServer({ schema: subgraphSchema, // ...other options... });  ","version":"Next","tagName":"h3"},{"title":"Unions and interfaces","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"Union​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#union","content":"当你定义一个 union 类型时，你声明的对象类型可以被包含在 union 中。 union Media = Book | Movie  一个字段可以将一个 union 类型(或者一个 union 类型的列表)，作为它的返回值类型。它可以返回任一被包含在 union 中的对象类型。 type Query { allMedia: [Media] # This list can include both Book and Movie objects }  union 类型所包含的所有类型，必须是对象类型(不能是 scalar、input 类型)。被包含的类型之间，不需要共享任何字段。 私货：被包含的类型之间，可以是毫无关联的类型，字段不需要有相似性。 ","version":"Next","tagName":"h2"},{"title":"例子​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#例子","content":"下面的 schema 定义了一个名为SearchResult的 union 类型。它可以返回一本Book或一位Author： union SearchResult = Book | Author type Book { title: String! } type Author { name: String! } type Query { search(contains: String): [SearchResult!] }  SearchResult类型允许Query.search返回一个包含Books 和Authors 的列表。 ","version":"Next","tagName":"h3"},{"title":"查询一个 union​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#查询一个-union","content":"如果一个返回值的类型，是 union 时，GraphQL 客户端不知道字段将返回哪个对象类型。为此，一个查询可以包含多种可能类型的子字段。 下面是一个查询 schema 的示例： query GetSearchResults { search(contains: &quot;Shakespeare&quot;) { # Querying for __typename is almost always recommended, # but it's even more important when querying a field that # might return one of multiple types. __typename ... on Book { title } ... on Author { name } } }  什么是__typename字段？ 这个查询使用 inline fragment 语法去查询SearchResult的title(如果他是Book)或name(如果他是Author)。web 客户端可以被 passing the possibleTypes option告知关于这个多态的关系。 私货：passing possibleTypes option 是个啥？ 下面是前面查询的返回结果： { &quot;data&quot;: { &quot;search&quot;: [ { &quot;__typename&quot;: &quot;Book&quot;, &quot;title&quot;: &quot;The Complete Works of William Shakespeare&quot; }, { &quot;__typename&quot;: &quot;Author&quot;, &quot;name&quot;: &quot;William Shakespeare&quot; } ] } }  ","version":"Next","tagName":"h3"},{"title":"解析一个 union​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#解析一个-union","content":"阅读本章节前，建议先了解resolver 为了全面解析 union，Apollo Server 需要确认 union 将会返回哪一种类型。为此，你需要在 resolver map 中，为 union 定义一个__resolveType函数。 __resolveType函数负责确定一个对象的 GraphQL 返回类型并且以字符串的形式返回类型名称。可以通过任意逻辑来完成这件事，例如： 检查字段上的某具有唯一特征的值是否存在如果 JavaScript 对象的类型与 GraphQL 的类型相关连，则使用instanceOf。 下面是一个为SearchResult定义的__resovleType函数： const resolvers = { SearchResult: { __resolveType(obj, contextValue, info){ // Only Author has a name field if(obj.name){ return 'Author'; } // Only Book has a title field if(obj.title){ return 'Book'; } return null; // GraphQLError is thrown }, }, Query: { search: () =&gt; { ... } }, }; const server = new ApolloServer({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server); console.log(`🚀 Server ready at: ${url}`);  如果__resolveType函数返回一个与 schema 类型定义不相符的值，与其相关的 operation 将产生一个 GraphQL 错误。 ","version":"Next","tagName":"h3"},{"title":"interface​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#interface","content":"一个 interface 确定了多个对象类型都可以包含的一批字段： interface Book { title: String! author: Author! }  如果一个对象类型implements了一个 interface，它一定可以具备 interface 所有的字段： type Textbook implements Book { title: String! # Must be present author: Author! # Must be present courses: [Course!]! }  一个字段可以将一个 interface(或者一个 interface 的列表)作为返回类型。在这种情况下，这个字段可以返回任意一个implements了这个 interface 的对象类型： type Query { books: [Book!]! # Can include Textbook objects }  ","version":"Next","tagName":"h2"},{"title":"例子​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#例子-1","content":"下面的 schema 中定义了名为Book的 interface，并且有两个对象类型 implements 了它： interface Book { title: String! author: Author! } type Textbook implements Book { title: String! author: Author! courses: [Course!]! } type ColoringBook implements Book { title: String! author: Author! colors: [String!]! } type Query { books: [Book!]! }  在这个 scheme 中，Query.books可以返回包含Textbook和ColoringBook的列表。 ","version":"Next","tagName":"h3"},{"title":"查询一个 interface​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#查询一个-interface","content":"如果一个字段的类型是 interface，客户端可以查询这个 interface 的字段中的任意字段： query GetBooks { books { title author } }  客户端也可以查询这个 interface 没有包含的字段： query GetBooks { books { # Querying for __typename is almost always recommended, # but it's even more important when querying a field that # might return one of multiple types. __typename title ... on Textbook { courses { # Only present in Textbook name } } ... on ColoringBook { colors # Only present in ColoringBook } } }  什么是__typename 字段？ 这个查询使用内联片段去查询Book的courses字段(如果它属于Textbook类型)或者colors字段(如果它属于ColoringBook类型)。通过passing the possibleTypes option，web 客户端可以被告知关于这个多态关系。 下面是前面查询的一个有效结果： { &quot;data&quot;: { &quot;books&quot;: [ { &quot;__typename&quot;: &quot;Textbook&quot;, &quot;title&quot;: &quot;Wheelock's Latin&quot;, &quot;courses&quot;: [ { &quot;name&quot;: &quot;Latin I&quot; } ] }, { &quot;__typename&quot;: &quot;ColoringBook&quot;, &quot;title&quot;: &quot;Oops All Water&quot;, &quot;colors&quot;: [&quot;Blue&quot;] } ] } }  ","version":"Next","tagName":"h3"},{"title":"解析一个 interface​","type":1,"pageTitle":"Unions and interfaces","url":"/blog/docs/Apollo Server/Defining a Schema/union-and-interface#解析一个-interface","content":"阅读本章节前，建议了解resolver 与 union 类型相同，Apollo Server 需求 interface 定义一个__resolveType函数去确定那个哪一种对象类型将会被返回。 下面是一个Book的__resolveType函数的例子： const resolvers = { Book: { __resolveType(book, contextValue, info){ // Only Textbook has a courses field if(book.courses){ return 'Textbook'; } // Only ColoringBook has a colors field if(book.colors){ return 'ColoringBook'; } return null; // GraphQLError is thrown }, }, Query: { books: () =&gt; { ... } }, };  ","version":"Next","tagName":"h3"},{"title":"Custom scalars","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"定义 custom scalar​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#定义-custom-scalar","content":"将下面的语句添加到 schema 中，就可以定义一个 custom scalar 类型： scalar MyCustomScalar  你可以立刻使用 MyCustomScalar，在 schema 中可以使用默认 scalar 的地方(例如，对象字段的类型、input 类型的字段或者参数)。 不过，Apollo Server 需要知道如何处理新类型的值。 ","version":"Next","tagName":"h2"},{"title":"定义 custom scalar 的逻辑​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#定义-custom-scalar-的逻辑","content":"在定义一个 custom scalar 类型后，需要定义 Apollo Server 如何处理这个类型。需要定义下面几点： scalar 的值如何在后端表示 This is often the representation used by the driver for your backing data store.这通常是驱动程序用于备份数据存储的表示形式。 值的后端表现形式如何序列化为兼容 JSON 的类型兼容 JSON 的表现形式如何反序列化为后端的表现形式 在 GraphQLScalarType 类的实例中定义这些交互。 私货：表现形式，或许换成存储方式，更合适一点？ 更多关于graphql库的类型系统，参考官方文档 ","version":"Next","tagName":"h2"},{"title":"例子：Date scalar​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#例子date-scalar","content":"下面的代码，默认使用 Typescript.你可以使用每个代码块中的下拉菜单，切换到 JavaScript 的语言版本。 如果你正在使用 JavaScript，使用.js和.jsx文件扩展名而不是.ts和.tsx。 下面的 GraphQLScalarType 对象为一个展示日期（这是一个最常见的 custom scalar 实现方式）的 custom scalar 定义了处理逻辑。它假设我们的后端使用 JavaScript 的 Date 对象表达一个日期。 import { GraphQLScalarType, Kind } from &quot;graphql&quot;; const dateScalar = new GraphQLScalarType({ name: &quot;Date&quot;, description: &quot;Date custom scalar type&quot;, // backend to frontend serialize(value) { if (value instanceof Date) { return value.getTime(); // Convert outgoing Date to integer for JSON } throw Error(&quot;GraphQL Date Scalar serializer expected a `Date` object&quot;); }, // frontend to backend parseValue(value) { if (typeof value === &quot;number&quot;) { return new Date(value); // Convert incoming integer to Date } throw new Error(&quot;GraphQL Date Scalar parser expected a `number`&quot;); }, parseLiteral(ast) { if (ast.kind === Kind.INT) { // Convert hard-coded AST string to integer and then to Date return new Date(parseInt(ast.value, 10)); } // Invalid hard-coded value (not an integer) return null; }, });  这段初始化过程定了下面的方法： serializeparseValueparseLiteral 这些方法共同描述了 Apollo Server 在每一种场景下，如何与 scalar 进行交互。 ","version":"Next","tagName":"h2"},{"title":"serialize​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#serialize","content":"serialize方法将 scalar 的后端表达形式转换为兼容 JSON 的格式，使得 Apollo Server 可以将其包含在 operation 的响应中。 在前面的例子中，Date在后端以 JavaScript 的Date对象表示。当我们在 GraphQL 响应中发送一个Date scalar 时，我们通过 JavaScript Date对象的getTime函数，将其序列化为整形数值。 注意，Apollo 客户端无法自动解析 custom scalar(参考 issue)，所以你的客户端必须定义反序列化这个 scalar 值所需要的处理逻辑。 私货：这个反序列化的逻辑，是怎么应用到 client 的？方法应该是在 server 定义的 ","version":"Next","tagName":"h3"},{"title":"parseValue​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#parsevalue","content":"在 scalar 的 JSON 值被添加到 resolver 的args之前，parseValue方法将其转换为后端表示形式。 当客户端将 scalar 作为 GraphQL 变量传递给一个参数时，Apollo Server 会调用这个方法。(当 scalar 在 operation string 中，作为硬编码提供给参数时，会调用parseLiteral) 私货：operation string，指的是 operation 的字符串表达形式，类似下边的示例： query GetBooks { books { title author } }  ","version":"Next","tagName":"h3"},{"title":"parseLiteral​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#parseliteral","content":"当传入的查询字符串包含硬编码的 scalar 参数时，该值是查询文档的抽象语法树(AST)的一部分。Apollo Server 调用parseLiteral方法将该值的 AST 表示形式转换为 scalar 的后端表示形式。 在前面的例子中，parseLiteral将 AST 值从字符串转换为整数，然后从整形转换到Date，以符合parseValue的结果。 ","version":"Next","tagName":"h3"},{"title":"给 Apollo Server 提供 custom scalar​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#给-apollo-server-提供-custom-scalar","content":"在下面的例子中，我们使用顶层的 await 调用去异步起动服务器。如果你想看怎样配置这些，可以查看 Getting Started 以了解更多。 在定义GraphQLScalarType实例后，将其囊括在含有 schema 其他类型和字段的 resolver 的 resolver map 中。 import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; import { GraphQLScalarType, Kind } from &quot;graphql&quot;; const typeDefs = `#graphql scalar Date type Event { id: ID! date: Date! } type Query { events: [Event!] } `; const dateScalar = new GraphQLScalarType({ // See definition above }); const resolvers = { Date: dateScalar, // ...other resolver definitions... }; const server = new ApolloServer({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server); console.log(`🚀 Server listening at: ${url}`);  ","version":"Next","tagName":"h2"},{"title":"例子：限制整数为奇数​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#例子限制整数为奇数","content":"在这个例子中，我们创建一个名为Odd的 custom scalar，它只接受奇数： import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; import { GraphQLScalarType, Kind, GraphQLError } from &quot;graphql&quot;; // Basic schema const typeDefs = `#graphql scalar Odd type Query { # Echoes the provided odd integer echoOdd(odd: Odd!): Odd! } `; // Validation function for checking &quot;oddness&quot; function oddValue(value: number) { if (typeof value === &quot;number&quot; &amp;&amp; Number.isInteger(value) &amp;&amp; value % 2 !== 0) { return value; } throw new GraphQLError(&quot;Provided value is not an odd integer&quot;, { extensions: { code: &quot;BAD_USER_INPUT&quot; }, }); } const resolvers = { Odd: new GraphQLScalarType({ name: &quot;Odd&quot;, description: &quot;Odd custom scalar type&quot;, parseValue: oddValue, serialize: oddValue, parseLiteral(ast) { if (ast.kind === Kind.INT) { return oddValue(parseInt(ast.value, 10)); } throw new GraphQLError(&quot;Provided value is not an odd integer&quot;, { extensions: { code: &quot;BAD_USER_INPUT&quot; }, }); }, }), Query: { echoOdd(_, { odd }) { return odd; }, }, }; const server = new ApolloServer({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server); console.log(`🚀 Server listening at: ${url}`);  ","version":"Next","tagName":"h2"},{"title":"导入第三方的 custom scalar​","type":1,"pageTitle":"Custom scalars","url":"/blog/docs/Apollo Server/Defining a Schema/custom-scalars#导入第三方的-custom-scalar","content":"如果其他的库定义了 custom scalar，你可以导入并像其他类型一样使用它。 举个例子，graphql-type-json包定义了GraphQLJSON对象，它是GraphQLScalarType的一个实例。你可以使用这个对象去定义一个只接受有效 JSON 值的JSONscalar。 首先，安装库： $ npm install graphql-type-json  然后，像往常一样，将GraphQLJSON对象导入并添加到 resolver map 中： import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; import GraphQLJSON from &quot;graphql-type-json&quot;; const typeDefs = `#graphql scalar JSON type MyObject { myField: JSON } type Query { objects: [MyObject] } `; const resolvers = { JSON: GraphQLJSON, // ...other resolvers... }; const server = new ApolloServer({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server); console.log(`🚀 Server listening at: ${url}`);  ","version":"Next","tagName":"h2"},{"title":"Get Started with Apollo Server","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Get Started","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"Step 1：创建项目​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-1创建项目","content":"为新项目创建一个目录： mkdir graphql-server-example cd graphql-server-example  使用npm初始化 Node.js 项目(或者使用其他包管理器，例如 Yarn)： npm init --yes &amp;&amp; npm pkg set type=&quot;module&quot;  这份教程使用 ES Modules 设置项目，可以简化我们的示例并允许我们使用 top-level await。 现在，你的项目包含了一个package.json文件。 ","version":"Next","tagName":"h2"},{"title":"Step 2：安装依赖​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-2安装依赖","content":"运行 Apollo Server 需要 2 个顶层依赖： GraphQL(也被称作graphql-js)是实现核心 GraphQL 解析和执行算法的库。@apollo/server是 Apollo Server 自身主要的库。Apollo Server 知道如何将 HTTP 请求与响应转变为 GraphQL operation 并在支持插件和其他功能的、可扩展的上下文中运行它们。 运行下面的命令来安装这些依赖： npm install @apollo/server graphql  ","version":"Next","tagName":"h2"},{"title":"Step 3：定义 GraphQL schema​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-3定义-graphql-schema","content":"下面的代码块默认使用 TypeScript。你可以使用每个代码块前的下拉菜单来切换到 JavaScript。 如果正在使用 JavaScript，在.ts和.tsx出现的地方，使用.js和.jsx扩展名。 每个 GraphQL Server(包括 Apollo Server)使用 schema 来定义 client 可以 query 的数据的结构。在这个例子中，我们将创建一个 server，用于通过 title 和 author 来查询到 books 的集合。 打开index.ts import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; // A schema is a collection of type definitions (hence &quot;typeDefs&quot;) // that together define the &quot;shape&quot; of queries that are executed against // your data. const typeDefs = `#graphql # Comments in GraphQL strings (such as this one) start with the hash (#) symbol. # This &quot;Book&quot; type defines the queryable fields for every book in our data source. type Book { title: String author: String } # The &quot;Query&quot; type is special: it lists all of the available queries that # clients can execute, along with the return type for each. In this # case, the &quot;books&quot; query returns an array of zero or more Books (defined above). type Query { books: [Book] } `;  添加#graphql到模版字面量的开头，可以在一些 IDE 中开启 GraphQL 语法高亮。 这段代码定义了一个简单、有效的 schema。client 可以执行名为books的 query，并且我们的 server 将返回 0 或多个Book对象组成的数组。 ","version":"Next","tagName":"h2"},{"title":"Step 4：定义数据集​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-4定义数据集","content":"既然我们已经定义了数据的结构，我们就可以定义数据本身了。 Apollo Server 可以获取数据从你连接的任意数据源(包括数据库、REST API、静态对象存储服务或另一个 GraphQL server)。因为这份教程的目的，我们将硬编码我们示例使用的数据。 添加下面代码到index.ts文件底部： const books = [ { title: &quot;The Awakening&quot;, author: &quot;Kate Chopin&quot;, }, { title: &quot;City of Glass&quot;, author: &quot;Paul Auster&quot;, }, ];  这段代码定义了 client 可以查询的数据集。 注意，数组中的 2 个对象，每一个都符合我们在 schema 中定义的Book类型的结构。 ","version":"Next","tagName":"h2"},{"title":"Step 5：定义 resolver​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-5定义-resolver","content":"我们已经定义了数据集，但是 Apollo Server 不知道当它执行 query 时，应该如何使用这些数据。为了解决这个问题，我们创建 resolver。 Resolver 告诉 Apollo Server 如何获取关联特定类型的数据。因为我们的Book数组是硬编码的，所以相应的 resolver 非常简单。 添加下面代码到index.ts文件底部： // Resolvers define how to fetch the types defined in your schema. // This resolver retrieves books from the &quot;books&quot; array above. const resolvers = { Query: { books: () =&gt; books, }, };  ","version":"Next","tagName":"h2"},{"title":"Step 6：创建 Apollo Server 实例​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-6创建-apollo-server-实例","content":"我们已经定义了 schema、数据集和 resolver。现在我们需要在初始化 Apollo Server 的时候，给它提供这些信息。 添加下面代码到index.ts文件底部： // The ApolloServer constructor requires two parameters: your schema // definition and your set of resolvers. const server = new ApolloServer({ typeDefs, resolvers, }); // Passing an ApolloServer instance to the `startStandaloneServer` function: // 1. creates an Express app // 2. installs your ApolloServer instance as middleware // 3. prepares your app to handle incoming requests const { url } = await startStandaloneServer(server, { listen: { port: 4000 }, }); console.log(`🚀 Server ready at: ${url}`);  这份教程使用 Apollo Server 的 standalone web server。如果你想集成 Apollo Server 到你在用的 web 框架，例如 Express，参考我们的web framework integration。 ","version":"Next","tagName":"h2"},{"title":"Step 7：运行 server​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-7运行-server","content":"我们准备启动我们的 server！在项目根目录，执行以下命令： npm start  现在，你应该在控制台底部看到了下面的输出： 🚀 Server ready at: http://localhost:4000/  成功！ ","version":"Next","tagName":"h2"},{"title":"Step 8：执行第一个 query​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#step-8执行第一个-query","content":"现在，可以在我们的 server 上执行 GraphQL query 了。为了执行第一个 query，我们可以使用 Apollo Sandbox。 在浏览器访问http://localhost:4000，它将打开 Apollo Sandbox：  Sandbox UI 包括： Operation 面板，用于编写和查询 query(在中间)。Response 面板，用于显示 query 的结果(在右边)。标签页，用于 schema 查询、搜索和设置(在左边)。URL 输入框，用于连接其他的 GraphQL server(在左上角)。 我们的 server 支持一个名为books的 query，让我们来执行它！ 这里是用来执行books的 GraphQL query 字符串： query GetBooks { books { title author } }  粘贴这段字符串到 Operation 面板并点击右上角的蓝色按钮。结果(从我们硬编码的数据集计算出)会出现在 Response 面板中：  注意：如果 Apollo Sandbox 无法找到你的 schema，确认是否通过将introspection: true传递给ApolloServer构造函数，以开启 schema 的 introspection 功能。我们建议在生产环境中禁用 introspection 功能，因为它会暴露你的 schema 的细节。 GraphQL 最重要的理念之一，是 client 可以选择只查询它们需要的字段。从 query 字符串中删除author然后再执行。返回值更新为每个 book 对象只包含title字段！ ","version":"Next","tagName":"h2"},{"title":"完善示例​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#完善示例","content":"你可以在 Code Sandbox 访问并 fork 完整的示例代码： Edit in CodeSandbox ","version":"Next","tagName":"h2"},{"title":"进阶​","type":1,"pageTitle":"Get Started with Apollo Server","url":"/blog/docs/Apollo Server/Get Started#进阶","content":"这个示例应用是一个学习 Apollo Server 的良好开端。查看下面的资源，去学习更多关于 schema、resolver 和生成类型的基础： Schema basicsResolverGenerating TS types for your schema 想学习如何模块化和缩放 GraphQL API？查看 Apollo Federation Docs 以学习 federated 架构如何创建统一的、包含多个 GraphQL API 的 supergraph。 如果你想在特定 web 框架中使用 Apollo Server，参考我们的 list of integrations。如果我们没有你在用框架的集成方案，你可以创建一个以帮助我们的社区。 ","version":"Next","tagName":"h2"},{"title":"Introduction to Apollo Server","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Introduction","content":"Introduction to Apollo Server Apollo Server 是一个开源、符合规范的 GraphQL server， 它兼容任何 GraphQL client，包括 Apollo Client。这是构建可用于生产环境、自文档式、数据存储方式无关的 GraphQL API 的最佳方式。 你可以将 Apollo Server 用于：​ 将 GraphQL server 作为 federated GraphQL 中的 subgraph作为组件注入到现有的 Node.js 应用中。这些应用可以是基于 Express（包括MERN技术栈）、AWS Lambda、Azure Functions、Cloudflare、Fastify，和其他的框架或平台。 Apollo Server 可以提供什么能力：​ 配置简单，client 开发人员可以快速开发获取数据渐进引用，能够按照实际需求来添加功能特性优秀的兼容性，与任何数据源、构建工具和 GraphQL client 兼容可用于生产环境，可以自信地将 graph 运行在生产环境","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"GraphQL schema basics","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"The schema definition language​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#the-schema-definition-language","content":"GraphQL 规范 定义了方便人们阅读的 schema definition language(SDL)，SDL 用来定义 schema 的结构并且以字符串的形式存储。 这是一个简短的 schema 示例，包含了 2 种对象类型：Book 和 Author： type Book { title: String author: Author } type Author { name: String books: [Book] }  schema 定义了类型的集合和它们之间的关系。在上面的例子中，一本 Book 可以与一位 Author 关联，并且一位 Author 可以关联多本 Book。 因为这些关系被定义在统一、规范的 schema 中，客户端开发人员能够知道哪些数据是可用的，还可以在一个精简的 query 中查询到需要的数据。 注意，schema 不定义数据的来源与存储方式。schema 与实现完全无关。 ","version":"Next","tagName":"h2"},{"title":"字段定义​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#字段定义","content":"在 schema 中，大部分自定义的类型，都有一个或多个字段。 # This Book type has two fields: title and author type Book { title: String # returns a String author: Author # returns an Author }  每个字段都会返回类型定义的数据。一个字段返回的类型，可以是 scalar、object、enum、union 或者 interface。 ","version":"Next","tagName":"h2"},{"title":"字段列表​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#字段列表","content":"一个字段可以返回一个包含特定类型项目的列表。可以用[]来声明字段列表，就像这样： type Author { name: String books: [Book] # A list of Books }  ","version":"Next","tagName":"h3"},{"title":"字段能否为 null​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#字段能否为-null","content":"默认情况下，除非特殊声明，在 schema 中定义的字段，都是可以返回null的。你可以通过在字段定义中添加!来声明字段不能为null，就像这样： type Author { name: String! # Can't return null books: [Book] }  name 字段不能返回null。如果你的 GraphQL 服务尝试返回null，将会抛出一个错误。 列表能否为 null​ 在字段列表中，!可以出现在两个位置： type Author { books: [Book!]! # This list can't be null AND its list *items* can't be null }  如果!出现在方括号内部，意味着返回的列表中，列表项不能为null。如果!出现在方括号外部，意味着返回的列表本身不能为null。在任何情况下，字段列表都是可以返回一个空列表的 ","version":"Next","tagName":"h3"},{"title":"支持的类型​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#支持的类型","content":"所有定义在 GraphQL schema 中的类型，都属于以下类别之一： ScalarObject 对象包含 3 种特殊的根操作类型：Query、Muation 和 Subscription。 InputEnumUnionInterface 私货：其实，type 定义的，都可以算作 object。但是分为自定义类型，和 Query、Mutation、Subscription 这 3 种特殊的。input 定义的，结构上也算是 object，只是关键字换成了 input。 每一种在后文都有所描述。 ","version":"Next","tagName":"h2"},{"title":"Scalar​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#scalar","content":"Scalar 类型类似常用编程语言中的原始类型。它们总是解析为具体的数据类型。 GraphQL 默认的 scalar 类型有： Int：有符号 32-bit 整数Float：有符号 双精度 浮点数String：UTF-8 编码的字符串Boolean：true或者falseID(初始化为字符串)：一个常被用于获取对象或缓存键值的唯一标识。虽然被初始化为字符串，但ID并不是人类可读的。 这些原始类型覆盖了主要的使用场景。在更具体的场景中，可以创建 自定义 scalar 类型。 ","version":"Next","tagName":"h3"},{"title":"Object​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#object","content":"GraphQL schema 中，大多数自定义的类型，都是对象类型。一个对象类型包含了多个字段的集合，每个字段都拥有各自的类型。 两个 Object 类型可以互相包含彼此，作为各自字段的类型。例如我们之前示例所示： type Book { title: String author: Author } type Author { name: String books: [Book] }  __typename 字段​ 每一个 schema 中的 Object 类型，都会自动包含一个名为__typename的字段。这个字段，会以String的形式，返回该 Object 类型的名称(例如：Book和Author)。 GraphQL 客户端 可以通过对象的__typename来完成很多事情，例如一个可以返回多类型的字段，决定返回何种类型(例如：union 或者 interface)。Apollo 客户端 依靠__typename来缓存查询结果，因此它会在每个查询的对象中，自动包含__typename字段。 因为__typename总是有效的，所以下边的查询是合法的： query UniversalQuery { __typename }  ","version":"Next","tagName":"h3"},{"title":"Query​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#query","content":"Query是一种特殊的 Object 类型，它定义了所有用于提供给客户端查询的顶级入口。 Query类型下的每一个字段定义了不同入口点的名字与返回类型。Query类型的例子类似下面这样： type Query { books: [Book] authors: [Author] }  示例中的Query类型，定义了 2 个字段：books 和 authors。每个字段返回一个对应类型的列表。 使用基于 REST 的 API，books 和 authors 也许通过不同的端点返回(例如,/api/books和/api/authors)。GraphQL 的灵活性使得客户端可以用一个请求查询多种资源。 构建一个查询​ 当客户端构建查询去查询你的 GraphQL 服务时，这些查询结果的数据结构与 schema 中定义类型的结构相符。 基于目前所见的示例，客户端可以执行下边的查询，一个查询同时获取一个全部 book 名的列表和一个全部作者名的列表。 query GetBooksAndAuthors { books { title } authors { name } }  我们的服务器将会返回符合查询结构的结果，就像这样： { &quot;data&quot;: { &quot;books&quot;: [ { &quot;title&quot;: &quot;City of Glass&quot; }, ... ], &quot;authors&quot;: [ { &quot;name&quot;: &quot;Paul Auster&quot; }, ... ] } }  虽然在某些场景，一次查询两个独立的列表可能是有用的，但是客户端或许更倾向于查询单独的 books 列表，并且每本书的作者名包含在返回结果中。 因为我们 schema 中的Book类型有一个Author类型的author字段，客户端可以使用下边的查询替代上边的查询： query GetBooks { books { title author { name } } }  再一次，我们的服务器将会返回符合查询结构的结果： { &quot;data&quot;: { &quot;books&quot;: [ { &quot;title&quot;: &quot;City of Glass&quot;, &quot;author&quot;: { &quot;name&quot;: &quot;Paul Auster&quot; } }, ... ] } }  ","version":"Next","tagName":"h3"},{"title":"Mutation​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#mutation","content":"在结构、作用上，Mutation类型与Query类型极为相似。不过Query类型定义的入口点服务于read操作，而Mutation类型定义的入口点服务于write操作。 Mutation类型的每一个字段，都定义了不同的入口点签名和返回类型。Mutation类型的示例类似于下面这样： type Mutation { addBook(title: String, author: String): Book }  这个Mutation类型定义了一个可用的 mutation，addBook。这个 mutation 接受 2 个参数(title和author)并且返回一个新创建的Book对象。如你所想，这个Book对象的结构与 schema 定义中的相符。 构造一个 mutation​ 类似 query，mutation 与 schema 类型定义的结构相符。下面的 mutation 创建了新的Book并且请求新建对象中部分的字段作为返回值。 mutation CreateBook { addBook(title: &quot;Fox in Socks&quot;, author: &quot;Dr. Seuss&quot;) { title author { name } } }  与查询一样，我们的服务器将用一个符合 Mutation 结构的结果，来相应这个 mutation。就像这样： { &quot;data&quot;: { &quot;addBook&quot;: { &quot;title&quot;: &quot;Fox in Socks&quot;, &quot;author&quot;: { &quot;name&quot;: &quot;Dr. Seuss&quot; } } } }  单个 mutation 操作可以包括多个Mutation类型的顶层字段。这通常意味着一个 mutation 操作将执行多个后端的写入(每个字段至少一个)。为了阻止条件竞争，顶层Mutation字段按照顺序解析(所有其他字段可以被并行解析)。 了解更多关于 mutation 的设计 ","version":"Next","tagName":"h3"},{"title":"Subscription​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#subscription","content":"详情参考 Subscriptions ","version":"Next","tagName":"h3"},{"title":"Input​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#input","content":"Input 类型 是一种特殊的 object 类型，它允许你提供结构化数据作为参数提供给字段(尽量不要平铺大量 scalar 类型 作为参数)。 Input 类型 的定义与普通 object 类型相似，但它的关键字为input： input BlogPostContent { title: String body: String }  每一个 input 类型 的字段，可以是 scalar、enum 或者另一个 input 类型: input BlogPostContent { title: String body: String media: [MediaDetails!] } input MediaDetails { format: MediaFormat! url: String! } enum MediaFormat { IMAGE VIDEO }  定义 input 类型 后，任意数量的不同对象字段可以将其作为参数： type Mutation { createBlogPost(content: BlogPostContent!): Post updateBlogPost(id: ID!, content: BlogPostContent!): Post }  当多个操作需要相同信息集合的时候，input 类型 很有用，但你应该谨慎的复用它们。操作最终需要的参数也许会发生变化。 谨慎地同时在Query和Mutation的字段，使用相同的 input 类型。在很多场景，mutation 所需的参数，相对于查询，是可选的。你也许想创建单独的 input 类型 用于每一个操作类型。 ","version":"Next","tagName":"h3"},{"title":"Enum​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#enum","content":"私货：enum 属于缩小范围的 scalar。 enum 和 scalar 非常相似，但是它的合法值是在 schema 中被定义的。下面是一个定义的例子： enum AllowedColor { RED GREEN BLUE }  当用户必须从指定列表的选项中选择一个值的时候，enum 非常有用。另外一个好处，enum 值在 Apollo Studio Explorer 等工具中，能够自动补全。 enum 可以用在任何允许声明为 scalar 类型的地方(包括字段参数)，因为 enum 被初始化为字符串： type Query { favoriteColor: AllowedColor # enum return value avatar(borderColor: AllowedColor): String # enum argument }  一个查询看起来像这样： query GetAvatar { avatar(borderColor: RED) }  内部值(高级特性)​ 有些时候，后端强制 enum 内部使用一个与公开 API 不同的值。你可以在提供给 Apollo Server 的 resolver map 中，设置每个 enum 值以符合内部值。 这个特性通常是不必要的，除非应用中另一个库，期望 enum 以不同的形式展示。 下面的示例使用十六进制颜色代码来作为AllowedColor的内部值： const resolvers = { AllowedColor: { RED: &quot;#f00&quot;, GREEN: &quot;#0f0&quot;, BLUE: &quot;#00f&quot;, }, // ...other resolver definitions... };  这些内部值不影响公开 API。Apollo Server resolver 接收这些值而非 schema 中定义的值，如下所示： const resolvers = { AllowedColor: { RED: &quot;#f00&quot;, GREEN: &quot;#0f0&quot;, BLUE: &quot;#00f&quot;, }, Query: { favoriteColor: () =&gt; &quot;#f00&quot;, avatar: (parent, args) =&gt; { // args.borderColor is '#f00', '#0f0', or '#00f' }, }, };  ","version":"Next","tagName":"h3"},{"title":"Union 和 interface​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#union-和-interface","content":"详情参考 Unions and interfaces ","version":"Next","tagName":"h3"},{"title":"schema 的迭代​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#schema-的迭代","content":"随着项目的扩张和发展，graph 也会随之扩大。新产品和新功能需要更多的 schema 类型和字段。为了实时跟踪这些变化，你需要在版本库中维护 schema。 大多数增量变化对 schema 是安全的，并且可以向后兼容。然而，删除或者变更现有 schema 的行为可能会对 1 个或更多个客户端，造成破坏性变更。下面列出的变更是需要小心处理的破坏性变更： 删除类型或字段重命名类型或字段为字段添加可以为 null 的特性删除字段的参数 Apollo Studio 这类的 graph 管理工具，可以帮助你判断一个潜在的 schema 变更，是否会影响你正在使用的客户端。Studio 同样提供了字段级别的性能指标、schema 历史追踪，并且通过 operation 的安全清单，提供高级安全特性。 ","version":"Next","tagName":"h2"},{"title":"描述(文档字符串)​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#描述文档字符串","content":"GraphQL 的 schema definition language(SDL)支持 markdown 格式的文档字符串，称为描述。这些文档帮助 graph 的使用者了解字段并学习如何使用。 下面的示例展示了如何使用单行字符串字面量和多行字符块： &quot;Description for the type&quot; type MyObjectType { &quot;&quot;&quot; Description for field Supports **multi-line** description for your [API](http://example.com)! &quot;&quot;&quot; myField: String! otherField( &quot;Description for argument&quot; arg: Int ) }  高度文档化的 schema 有助于提供更好的开发体验，因为 GraphQL 开发工具(例如 Apollo GraphQL Exploer)自动补全字段名时，可以看到 schema 提供的描述。 而且，当Apollo Studio使用性能监控和 client awareness features 时，会把描述与字段使用情况和性能指标一起展示出来。 ","version":"Next","tagName":"h2"},{"title":"命名习惯​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#命名习惯","content":"GraphQL 规范 非常灵活，并且没有强制要求命名规范。不过，建立命名规范有助于确保一致性。我们建议使用以下约定： 字段名称：camelCase。许多 GraphQL 客户端是用 JavaScript、Java、Kotlin 或者 Swift 开发的，这些语言中，变量通常使用驼峰命名法。枚举值：ALL_CAPS。枚举值和常量比较相似。类型名称：PascalCase。JavaScript 等语言，类名通常使用帕斯卡命名法。枚举名称：PascalCase。 这些习惯有助于确保大多数客户端不需要定义额外的逻辑去转换服务端返回的结果。 ","version":"Next","tagName":"h2"},{"title":"查询驱动 schema 设计​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#查询驱动-schema-设计","content":"当 GraphQL schema 根据客户端执行 operation 的需求设计时，是最强大的。虽然可以自定义类型，但不必和后端数据存储的结构保持一致。一个对象类型的字段可以被任意数量、不同来源的数据填充。基于数据使用方式设计 schema，而不是存储方式。 如果你的数据存储方式包含客户端不需要的字段和关系，在 schema 中省略这些。与删除客户端正在使用的现有字段相比，向 schema 添加新字段更简单也更安全。 ","version":"Next","tagName":"h2"},{"title":"查询驱动 schema 的示例​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#查询驱动-schema-的示例","content":"我们正在创建一个展示即将到来的区域事件的 web 应用。我们希望这个应用展示名称、日期和每个事件的地点以及天气预报。 在这种情况下，我们希望我们的 web 应用能够执行类似下面结构的查询： query EventList { upcomingEvents { name date location { name weather { temperature description } } } }  因为我们知道这份数据的结构对我们的客户端有帮助，因此它可以为我们 schema 的结构提供信息： type Query { upcomingEvents: [Event!]! } type Event { name: String! date: String! location: Location } type Location { name: String! weather: WeatherInfo } type WeatherInfo { temperature: Float description: String }  如前所述，每一个类型可以填充不同来源的数据(或多个数据源的)。举个例子，Event类型的name和date也许被我们后端数据库的数据填充，而WeatherInfo类型使用第三方的天气 API 填充数据。 ","version":"Next","tagName":"h3"},{"title":"设计 mutation​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#设计-mutation","content":"在 GraphQL，建议所有 mutation 的返回值包含 mutation 修改的数据。这样可以使客户端获取最新的持久化数据而不用发送额外查询。 支持更新User的email的 schema，包括以下内容： type Mutation { # This mutation takes id and email parameters and responds with a User updateUserEmail(id: ID!, email: String!): User } type User { id: ID! name: String! email: String! }  然后，客户端能够根据 schema 的结构，来执行 mutation： mutation updateMyUser { updateUserEmail(id: 1, email: &quot;jane@example.com&quot;) { id name email } }  在 GraphQL 服务器 执行 mutation 并且存储新邮件地址后，将给客户端返回以下结果： { &quot;data&quot;: { &quot;updateUserEmail&quot;: { &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;Jane Doe&quot;, &quot;email&quot;: &quot;jane@example.com&quot; } } }  虽然不强制要求 mutation 的返回值中包含被修改的数据，但这样做可以更好的提升客户端代码的效率。和查询一样，明确 哪些 mutation 对客户端有用，有助于调整 schema 的结构。 ","version":"Next","tagName":"h2"},{"title":"构造 mutation 返回值​","type":1,"pageTitle":"GraphQL schema basics","url":"/blog/docs/Apollo Server/Defining a Schema/graphql-schema-basics#构造-mutation-返回值","content":"一个 mutation 可以修改多个类型，或者多个相同类型的实例。举个例子，使用户能够给博客文章点赞的 mutation 可能会增加一篇Post的likes数量并且更新用户的likedPosts列表。这使得 mutation 返回值的结构，看起来不那么明显。 私货：原文使用了 increment，看起来是语法错误，个人认为是 increase。 另外，由于 mutation 会修改数据，所以比查询更容易引发错误。mutation 甚至可能引发部分错误，一部分数据修改成功，而另外一部分失败了。无论什么样的错误类型，重要的是能以一致的方式通知客户端。 为了解决这些担忧，我们建议在 schema 中定义MutationResponse接口，连同一个实现了这个接口的对象类型集合(每个 mutation 一个)。 下面是MutationResponse接口可能的结构： interface MutationResponse { code: String! success: Boolean! message: String! }  下面是实现了MuatationResponse接口对象可能的结构： type UpdateUserEmailMutationResponse implements MutationResponse { code: String! success: Boolean! message: String! user: User }  我们的updateUserEmailmutation 将指定UpdateUserEmailMutationResponse作为返回类型(而不是User),并且返回值结构类似下面这样： { &quot;data&quot;: { &quot;updateUserEmail&quot;: { &quot;code&quot;: &quot;200&quot;, &quot;success&quot;: true, &quot;message&quot;: &quot;User email was successfully updated&quot;, &quot;user&quot;: { &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;Jane Doe&quot;, &quot;email&quot;: &quot;jane@example.com&quot; } } } }  让我们逐个分析这些字段： code是一个表达数据传输状态的字符串。可以理解为 HTTP 状态码。success是一个指示 mutation 是否执行成功的布尔值。这个值允许通过客户端进行粗略的检查，以获知是否存在问题。message是一个描述 mutation 结果、人类可读的字符串。旨在用于产品的 UI 界面。user是通过实现UpdateUserEmailMutationResponse类型被添加的，为了给客户端返回最新的 user 信息。 如果 mutation 修改多个类型(类似之前的给博客文章点赞的例子)，它的实现类型可以包括每个被修改类型中，一个单独的字段。 type LikePostMutationResponse implements MutationResponse { code: String! success: Boolean! message: String! post: Post user: User }  因为我们假设的likePostmutation 同时修改了Post和User,它的返回值包括这些类型的字段。返回值类似下面的结构： { &quot;data&quot;: { &quot;likePost&quot;: { &quot;code&quot;: &quot;200&quot;, &quot;success&quot;: true, &quot;message&quot;: &quot;Thanks!&quot;, &quot;post&quot;: { &quot;id&quot;: &quot;123&quot;, &quot;likes&quot;: 5040 }, &quot;user&quot;: { &quot;likedPosts&quot;: [&quot;123&quot;] } } } }  遵从这个模式，可以给客户端提供每个请求操作结果，有用且详细的信息。有了这些信息，开发者可以更好的在客户端代码排查错误。 ","version":"Next","tagName":"h3"},{"title":"Context and contextValue","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Resolving Operations/sharing-context","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"context函数​","type":1,"pageTitle":"Context and contextValue","url":"/blog/docs/Apollo Server/Resolving Operations/sharing-context#context函数","content":"Apollo Server 4 变更了定义context函数的语法。更多信息参考more details。 context函数是异步的，并且返回一个对象。服务器的 resolver 和 plugin 可以使用contextValue访问这个对象。 可以传递context函数给选择(例如expressMiddleware或startStandaloneServer)的内置函数。 服务器在每个请求都会调用一次context函数，使得可以定制每一次请求细节的contextValue(例如 HTTP headers)。 import { GraphQLError } from &quot;graphql&quot;; const resolvers = { Query: { // Example resolver adminExample: (parent, args, contextValue, info) =&gt; { if (contextValue.authScope !== ADMIN) { throw new GraphQLError(&quot;not admin!&quot;, { extensions: { code: &quot;UNAUTHENTICATED&quot; }, }); } }, }, }; const server = new ApolloServer({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server, { // Your async context function should async and // return an object context: async ({ req, res }) =&gt; ({ authScope: getScope(req.headers.authorization), }), });  前面的例子假设你正在使用startStandaloneServer或expressMiddleware，它们都使用 Express 作为基础库。 如果你使用不同的框架，context函数接收的参数也许不同。 如果你正在使用 Typescript，且通过向ApolloServer传递一个带类型的参数来键入 context(也就是说，你不使用ApolloServer&lt;BaseContext&gt;)，你必须提供名为context的函数。 因为context初始化函数是异步的，所以可以使用它去建立数据库连接并等待其他操作完成。 context: async () =&gt; ({ db: await client.connect(), }) // Resolver (parent, args, contextValue, info) =&gt; { return contextValue.db.query('SELECT * FROM table_name'); }  ","version":"Next","tagName":"h2"},{"title":"抛出错误​","type":1,"pageTitle":"Context and contextValue","url":"/blog/docs/Apollo Server/Resolving Operations/sharing-context#抛出错误","content":"默认情况下，如果context函数抛出一个错误，Apollo Server 会在 JSON 响应中返回该错误，并带有 500 HTTP 状态代码。如果这个错误不是GraphQLError，错误信息的前缀带有Context creation failed: 。 你可以通过抛出带有 http 扩展的GraphQLError，来修改错误信息中的 HTTP 状态码。例如： context: async ({ req }) =&gt; { const user = await getUserFromReq(req); if (!user) { throw new GraphQLError('User is not authenticated', { extensions: { code: 'UNAUTHENTICATED', http: { status: 401 }, } }); } // If the below throws a non-GraphQLError, the server returns // `code: &quot;INTERNAL_SERVER_ERROR&quot;` with an HTTP status code 500, and // a message starting with &quot;Context creation failed: &quot;. const db = await getDatabaseConnection(); return { user, db }; },  ","version":"Next","tagName":"h3"},{"title":"contextValue对象​","type":1,"pageTitle":"Context and contextValue","url":"/blog/docs/Apollo Server/Resolving Operations/sharing-context#contextvalue对象","content":"context函数返回一个contextValue对象，它可以被 plugin 和 resolver 访问。 ","version":"Next","tagName":"h2"},{"title":"resolver​","type":1,"pageTitle":"Context and contextValue","url":"/blog/docs/Apollo Server/Resolving Operations/sharing-context#resolver","content":"resolver 永远不该破坏性的修改contextValue参数。这样可以确保 resolver 之间的一致性并减少非预期的错误。 resolver 通过第三个参数，可以访问共享的contextValue对象。所有为特定 operation 执行的 resolver 都可以访问contextValue： import { AnimalAPI } from &quot;./datasources/animals&quot;; const resolvers = { Query: { // All of our resolvers can access our shared contextValue! dogs: (_, __, contextValue) =&gt; { return contextValue.dataSources.animalApi.getDogs(); }, cats: (_, __, contextValue) =&gt; { return contextValue.dataSources.animalApi.getCats(); }, }, }; const server = new ApolloServer({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server, { context: async () =&gt; { const animalApi = new AnimalAPI(); return { dataSources: { animalApi, }, }; }, });  ","version":"Next","tagName":"h3"},{"title":"plugin​","type":1,"pageTitle":"Context and contextValue","url":"/blog/docs/Apollo Server/Resolving Operations/sharing-context#plugin","content":"内置的和自定义 plugin 通过请求生命周期函数，都可以访问contextValue，像下面这样： const server = new ApolloServer({ typeDefs, resolvers: { Query: { hello: (root, args, { token }) =&gt; { return token; }, }, }, plugins: [ { async requestDidStart({ contextValue }) { // token is properly inferred as a string console.log(contextValue.token); }, }, ], }); const { url } = await startStandaloneServer(server, { context: async ({ req, res }) =&gt; ({ token: await getTokenForRequest(req), }), });  ","version":"Next","tagName":"h3"},{"title":"Error handling","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"内置错误码​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#内置错误码","content":"错误码\t描述GRAPHQL_PARSE_FAILED\t这个 GraphQL operation 的字符串中包含语法错误 GRAPHQL_VALIDATION_FAILED\t这个 GraphQL operation 相对于服务器的 schema 是无效的 BAD_USER_INPUT\t这个 GraphQL operation 某个字段的参数包含无效的值 PERSISTED_QUERY_NOT_FOUND\t客户端发送了 query 字符串的 hash，通过 automatic persisted queries (APQ)去执行，但是这个 query 没有在 APQ 缓存中 PERSISTED_QUERY_NOT_SUPPORTED\t客户端发送了 query 字符串的 hash，通过 automatic persisted queries (APQ)去执行，但是服务器禁用了 APQ。 OPERATION_RESOLUTION_FAILURE\t这个请求成功通过了语法分析并且相对于服务器的 schema 也是有效的，但是服务器无法解析要运行哪一个 operation。这个错误出现在一个请求包含多个命名 operation 但没有明确哪一个 operation 要运行的时候(也就是operationName)或者请求中没有包含命名 operation。 BAD_REQUEST\t一个出现在服务器尝试对接收的 GraphQL operation 进行语法解析之前的错误。 INTERNAL_SERVER_ERROR\t出现不确定的错误。当 Apollo Server 在一个响应中格式化错误信息时，如果没有设置其他错误码，它会将代码扩展设置为这个错误码。 ","version":"Next","tagName":"h2"},{"title":"Custom error​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#custom-error","content":"你可以使用graphql包的GraphQLError创建 custom error 和 code，像下面这样： import { GraphQLError } from &quot;graphql&quot;; throw new GraphQLError(message, { extensions: { code: &quot;YOUR_ERROR_CODE&quot;, myCustomExtensions }, });  custom error 可以提供额外的 context，使客户端能够理解错误发生的原因。我们建议明确场景对应的错误信息。例如，当一个用户没有登录(UNAUTHENTICATED)，或者某人被禁止执行操作： import { GraphQLError } from &quot;graphql&quot;; throw new GraphQLError(&quot;You are not authorized to perform this action.&quot;, { extensions: { code: &quot;FORBIDDEN&quot;, }, });  ","version":"Next","tagName":"h2"},{"title":"Throwing error​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#throwing-error","content":"Apollo Server 在适当的时候，自动地抛出错误。举个例子，当传入的 operation 相对于服务器的 schema 无效时，它抛出GRAPHQL_VALIDATION_FAILED错误。 在 Apollo Server 不会自动抛出错误的情况下,你的 resolver 也可以主动抛出错误。 举个例子，这个 resolver 抛出一个 custom error，如果提供给 user 的 ID 的数值小于1: import { GraphQLError } from &quot;graphql&quot;; const typeDefs = `#graphql type Query { userWithID(id: ID!): User } type User { id: ID! name: String! } `; const resolvers = { Query: { userWithID: (_, args) =&gt; { if (args.id &lt; 1) { throw new GraphQLError(&quot;Invalid argument value&quot;, { extensions: { code: &quot;BAD_USER_INPUT&quot;, }, }); } // ...fetch correct user... }, }, };  如果 resolver 抛出一个不是GraphQLError的普通错误，这个错误仍然会带着包含stackTrace信息的extension字段和code抛出(特别是INTERNAL_SERVER_ERROR),以及其他相关的错误信息。 ","version":"Next","tagName":"h2"},{"title":"包含 custom error 细节​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#包含-custom-error-细节","content":"无论何时抛出GraphQLError，都可以添加任意字段到 error 的extensions对象以提供额外的上下文给客户端。你可以在传递给 error 构造函数的对象中指定这些字段。 这个例子以前面的示例的基础上，添加了无效 GraphQL 参数的名称： import { GraphQLError } from &quot;graphql&quot;; const typeDefs = `#graphql type Query { userWithID(id: ID!): User } type User { id: ID! name: String! } `; const resolvers = { Query: { userWithID: (_, args) =&gt; { if (args.id &lt; 1) { throw new GraphQLError(&quot;Invalid argument value&quot;, { extensions: { code: &quot;BAD_USER_INPUT&quot;, argumentName: &quot;id&quot;, }, }); } // ...fetch correct user... }, }, };  这个响应结果类型下面这样： { &quot;errors&quot;: [ { &quot;message&quot;: &quot;Invalid argument value&quot;, &quot;locations&quot;: [ { &quot;line&quot;: 2, &quot;column&quot;: 3 } ], &quot;path&quot;: [&quot;userWithID&quot;], &quot;extensions&quot;: { &quot;code&quot;: &quot;BAD_USER_INPUT&quot;, &quot;argumentName&quot;: &quot;id&quot;, &quot;stacktrace&quot;: [ &quot;GraphQLError: Invalid argument value&quot;, &quot; at userWithID (/my-project/index.js:25:13)&quot;, &quot; ...more lines...&quot; ] } } ] }  ","version":"Next","tagName":"h3"},{"title":"省略或包含stackTrace​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#省略或包含stacktrace","content":"当开发或调试服务的时候，stackTrace字段很有帮助，但是你或许不想将这些信息暴露给在生产环境的客户端。 默认情况下，如果NODE_ENV环境变量设置为production或test，Apollo Server 会省略stackTrace字段。 通过传递includeStacktraceInErrorResponse选项给Apollo Server的构造函数，你可以覆盖默认行为。如果includeStacktraceErrorResponse设置为true,stackTrace永远都会被包含。如果设置为false，stackTrace永远被省略。 注意，当stackTrace被省略的时候，它对于你的应用同样不可用。要记录stackTrace的错误，且不在给客户端的响应中包含它们，参考 屏蔽和记录错误。 ","version":"Next","tagName":"h2"},{"title":"屏蔽和记录错误​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#屏蔽和记录错误","content":"你可以编辑 Apollo Server 错误详情，在它们被传递给客户端或报告给 Apollo Studio 之前。这使得你可以移除敏感或无关紧要的数据。 ","version":"Next","tagName":"h2"},{"title":"针对客户端响应​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#针对客户端响应","content":"在前面的例子中，我们使用顶层的await异步起动我们的服务。如果你想了解如何配置，查看 Getting Started 以了解详细信息。 ApolloServer构造函数接收formatErrorhook，它运行在每一个错误被传递给客户端之前。你可以使用这个函数记录或屏蔽指定的错误。 formatErrorhook 接收 2 个参数：第一个是被格式化为 JSON 格式的错误对象(将随着响应被发送)，第二个参数是原始错误(如果由 resolver 抛出，则包装为GraphQLError)。 formatError函数不会修改作为使用报告一部分被发送给 Apollo Studio 的错误。参考For Apollo Studio resporting。 无论 Apollo Server 何时抛出GRAPHQL_VALIDATION_FAILED错误，下面的例子会返回一个对用户友好的信息： import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; import { ApolloServerErrorCode } from &quot;@apollo/server/errors&quot;; const server = new ApolloServer({ typeDefs, resolvers, formatError: (formattedError, error) =&gt; { // Return a different error message if ( formattedError.extensions.code === ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED ) { return { ...formattedError, message: &quot;Your query doesn't match the schema. Try double-checking it!&quot;, }; } // Otherwise return the formatted error. This error can also // be manipulated in other ways, as long as it's returned. return formattedError; }, }); const { url } = await startStandaloneServer(server); console.log(`🚀 Server listening at: ${url}`);  另一个例子，无论何时，只要原始的错误信息以Database Error: 开头，我们返回一个更普通的错误： formatError: (formattedError, error) =&gt; { if (formattedError.message.startsWith('Database Error: ')) { return { message: 'Internal server error' }; } // Otherwise return the formatted error. return formattedError; },  如果你想访问原始的报错(没有格式化为 JSON 的)，你可以使用formateError的第二个参数。 举个例子，如果你在应用中使用了一个 database 库，并且当服务抛出一个特定类型的数据库错误时，你希望做一些处理： formatError: (formattedError, error) =&gt; { if (error instanceof CustomDBError) { // do something specific } },  注意，如果resolver抛出一个错误，GraphQLError被包装在初试错误外层。GraphQLError整齐地格式化错误并且包含有用的字段，例如错误出现在哪里的path。 如果你想移除外层的GraphQLError以访问原始的错误，你可以从@apollo/server/errors引用unwrapResolverError。unwrapResolverError函数可以从 resolver 错误移除GraphQLError封装，如果这个错误不是 resolver 抛出的，则返回未修改的错误。 所以，我们可以重写前面的代码片段来处理 resolver 内部与外侧抛出错误，例如： import { unwrapResolverError } from &quot;@apollo/server/errors&quot;; new ApolloServer({ formatError: (formattedError, error) =&gt; { // unwrapResolverError removes the outer GraphQLError wrapping from // errors thrown in resolvers, enabling us to check the instance of // the original error if (unwrapResolverError(error) instanceof CustomDBError) { return { message: &quot;Internal server error&quot; }; } }, });  为了使特定的 context 适配通过formatError接收的错误(例如本地化和个性化)，考虑创建一个插件，它使用didEncounterErrors声明周期事件去添加额外的属性给这个错误。这些属性可以从formatError访问。 ","version":"Next","tagName":"h3"},{"title":"For Apollo Studio reporting​","type":1,"pageTitle":"Error handling","url":"/blog/docs/Apollo Server/Resolving Operations/error-handling#for-apollo-studio-reporting","content":"在 Apollo Server 4 中：默认配置下，错误细节不会被包含在 trace 中。作为替代，&lt;masked&gt;替换每一个错误信息，并且maskedBy错误扩展替换其他扩展。maskedBy扩展包含了执行遮罩的插件名字(ApolloServerPluginUsageReporting或ApolloServerPluginInlineTrace) 你可以使用 Apollo Studio 来分析你服务的错误率。默认配置下，作为详细跟踪发送给 Studio 的 operation 不包含错误详细信息。 如果确实想将错误信息发送给 Studio，你可以发送每一个错误，在它们被传播前，你也可以修改或校对错误信息。 为了发送全部错误信息到 Studio，你可以传递{ unmodified: true }给sendErrors，像下面这样： new ApolloServer({ // etc. plugins: [ ApolloServerPluginUsageReporting({ // If you pass unmodified: true to the usage reporting // plugin, Apollo Studio receives ALL error details sendErrors: { unmodified: true }, }), ], });  如果你想报告特定错误或在一个错误被报告前修改它，你可以传递函数给sendErrors.trarnsform配置，像下面这样： new ApolloServer({ // etc. plugins: [ ApolloServerPluginUsageReporting({ sendErrors: { transform: (err) =&gt; { if (err.extensions.code === &quot;MY_CUSTOM_CODE&quot;) { // returning null will skip reporting this error return null; } // All other errors are reported. return err; }, }, }), ], });  如果你提供一个 Apollo API key 给 Apollo Server，usage reporting plugin 会作为默认配置自动安装。去定制 usage reporting plugin 的行为，你需要用定制化配置安装它，像下面的例子一样。 ","version":"Next","tagName":"h3"},{"title":"Resolvers","type":0,"sectionRef":"#","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers","content":"","keywords":"lin-xii 林十二 林十二XII blog 博客 小破站","version":"Next"},{"title":"定义 resolver​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#定义-resolver","content":"","version":"Next","tagName":"h2"},{"title":"基础语法​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#基础语法","content":"假设我们服务器定义了以下(非常简短)的 schema： type Query { numberSix: Int! # Should always return the number 6 when queried numberSeven: Int! # Should always return 7 }  我们想要给根Query类型的numberSix和numberSeven字段定义 resolver，以让它们在需要的时候，永远返回6和7。 这些 resolver 的定义大概如下： const resolvers = { Query: { numberSix() { return 6; }, numberSeven() { return 7; }, }, };  如例子所示：​ 服务器上所有的 resolver 被定义在一个单独的 JavaScript 对象中(前面示例中被命名为resolvers)。这个对象被称作resolver map。resolver map 拥有与 schema 的类型(如前面示例中的Query)相对应的顶级字段。每一个 resolver 函数都属于对应字段所属的类型。 私货：resolver 和 resolver map，不是一个概念。 resolver-&gt;field resolver map-&gt;top-level type(更偏向 schema 整体的层级) ","version":"Next","tagName":"h3"},{"title":"传递参数​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#传递参数","content":"假设我们定义了如下的 schema： type User { id: ID! name: String } type Query { user(id: ID!): User }  我们希望能够通过 user 的id来查询user字段，以获取 user 对应的信息。 为了达到这个目的，我们的服务器需要访问 user 数据。针对这个认为的例子，假设我们的服务器定义了如下硬编码的数组： const users = [ { id: &quot;1&quot;, name: &quot;Elizabeth Bennet&quot;, }, { id: &quot;2&quot;, name: &quot;Fitzwilliam Darcy&quot;, }, ];  现在我们可以给user字段定义 resolver，像下面这样： const resolvers = { Query: { user(parent, args, contextValue, info) { return users.find((user) =&gt; user.id === args.id); }, }, };  如例子所示：​ resolver 可以选择接收四个参数：(parent, args, contextValue, info) 更多细节，参考arguments args参数是一个对象，它包含了通过 GraphQL operation 提供给字段的所有 GraphQL 参数。 注意，这个例子没有给User字段(id和name)定义 resolver。是因为 Apollo Server 为这些字段创建的 default resolver 做了正确的事：它直接从对象获取值并通过userresolver 返回。 ","version":"Next","tagName":"h3"},{"title":"将 resolver map 传递给 Apollo Server​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#将-resolver-map-传递给-apollo-server","content":"在下面的例子中，我们使用顶层await来异步起动我们的服务器。如果你想了解如何配置，请查看 Getting Started 获取更多详细信息。 在定义了所有 resolver 之后，搭配着 schema 的定义(作为typeDefs属性)一起，将它们(作为resolvers属性)传递给Apollo Server的构造函数。 下面的例子定义了硬编码的数据集、schema 和 resolver map。在将 schema 和 resolver map 传递给Apollo Server后初始化了实例。 import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; // Hardcoded data store const books = [ { title: &quot;The Awakening&quot;, author: &quot;Kate Chopin&quot;, }, { title: &quot;City of Glass&quot;, author: &quot;Paul Auster&quot;, }, ]; // Schema definition const typeDefs = `#graphql type Book { title: String author: String } type Query { books: [Book] } `; // Resolver map const resolvers = { Query: { books() { return books; }, }, }; // Pass schema definition and resolvers to the // ApolloServer constructor const server = new ApolloServer({ typeDefs, resolvers, }); // Launch the server const { url } = await startStandaloneServer(server); console.log(`🚀 Server listening at: ${url}`);  注意，你可以在多个文件和对象中定义 resolver，只要将所有 resolver 合并到一个单独的、被传递给ApolloServer构造函数的 resolver map 即可。 ","version":"Next","tagName":"h2"},{"title":"Resolver chain​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#resolver-chain","content":"当 query 请求一个返回值为对象类型的字段时，这个 query 至少也要访问该对象(如果没有查询该对象中的字段，没有理由在 query 中包含这个对象)字段中的一个。一个 query 最底层的字段，永远返回 scalar、enum 或者它们的列表。 私货：bottom out，最底层？我好像明白了，但是嘴说不出来 🤣 举个例子，Product类型的所有字段都属于“bottom out”： type Product { id: ID! name: String variants: [String!] availability: Availability! } enum Availability { AVAILABLE DISCONTINUED }  由于这个规则，Apollo Server 解析一个返回值为对象类型的字段时，它永远会解析这个对象的一个或更多字段。那些子字段或许也包含对象类型。根据 schema，object-field 模式可以持续到任意深度，这个过程被称为 resolver chain。 ","version":"Next","tagName":"h2"},{"title":"例子​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#例子","content":"假设服务器定义了如下的 schema： # A library has a branch and books type Library { branch: String! books: [Book!] } # A book has a title and author type Book { title: String! author: Author! } # An author has a name type Author { name: String! } type Query { libraries: [Library] }  下面是一个针对该 schema 有效的 query： query GetBooksByLibrary { libraries { books { author { name } } } }  这个 query 的 resolver chain 查询过程，符合 query 本身的层级结构： 这些 resolver 按前面所示的顺序执行，并且它们各自的返回值都会通过parent参数传递给下一个处于 resolver chain 中的 resolver。 这里有一段代码示例，它可以用这个 resolver chain 解析前面的 query： import { ApolloServer } from &quot;@apollo/server&quot;; import { startStandaloneServer } from &quot;@apollo/server/standalone&quot;; const libraries = [ { branch: &quot;downtown&quot;, }, { branch: &quot;riverside&quot;, }, ]; // The branch field of a book indicates which library has it in stock const books = [ { title: &quot;The Awakening&quot;, author: &quot;Kate Chopin&quot;, branch: &quot;riverside&quot;, }, { title: &quot;City of Glass&quot;, author: &quot;Paul Auster&quot;, branch: &quot;downtown&quot;, }, ]; // Schema definition const typeDefs = `#graphql # A library has a branch and books type Library { branch: String! books: [Book!] } # A book has a title and author type Book { title: String! author: Author! } # An author has a name type Author { name: String! } # Queries can fetch a list of libraries type Query { libraries: [Library] } `; // Resolver map const resolvers = { Query: { libraries() { // Return our hardcoded array of libraries return libraries; }, }, Library: { books(parent) { // Filter the hardcoded array of books to only include // books that are located at the correct branch return books.filter((book) =&gt; book.branch === parent.branch); }, }, Book: { // The parent resolver (Library.books) returns an object with the // author's name in the &quot;author&quot; field. Return a JSON object containing // the name, because this field expects an object. author(parent) { return { name: parent.author, }; }, }, // Because Book.author returns an object with a &quot;name&quot; field, // Apollo Server's default resolver for Author.name will work. // We don't need to define one. }; // Pass schema definition and resolvers to the // ApolloServer constructor const server = new ApolloServer({ typeDefs, resolvers, }); // Launch the server const { url } = await startStandaloneServer(server); console.log(`🚀 Server listening at: ${url}`);  如果更新 query 还去查询每本 book 的title字段： query GetBooksByLibrary { libraries { books { title author { name } } } }  resolver chain 看起来就是下面的样子了： 当一个 resolver chain 像这样分叉后，每一个 subchain 都可以并行执行。 ","version":"Next","tagName":"h3"},{"title":"Resolver 参数​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#resolver-参数","content":"resolver 函数被传递了 4 种参数：parent、args、contextValue和info(按顺序排列)。 你可以在代码中使用任何名字来命名这些参数，但是 Apollo 文档使用这些名称作为惯例。也常用父类型的名字或source来替代parent。 参数\t描述parent\t这个字段父级 resolver 的返回值(也就是指，resolver chain 中的前一个 resolver)。 对于没有父级的顶级字段的 resolver(例如Query的字段)，这个值从传递给 Apollo Server 构造函数的rootValue函数获取。 args\t一个包括提供给这个字段全部 GraphQL 参数的对象。举个例子，当执行query{ user(id: &quot;4&quot;)}时，被传递给userresolver 的args对象是{ &quot;id&quot;: &quot;4&quot;} contextValue\t在一个 operation 执行的全部 resolver 中共享的对象。使用这个对象分享给每个 operation 的状态，包括认证信息、dataloader 实例和任何其他跨 resolver 访问的信息。查看contextValue argument以了解更多信息。 info\t容纳关于 operation 执行状态的信息，包括字段名称、从根字段到这个字段的路径和更多信息。它的核心字段被列在GraphQL.js 源码。Apollo Server 使用cacheControl字段来完善它。 ","version":"Next","tagName":"h2"},{"title":"contextValue参数​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#contextvalue参数","content":"resolver 永远不应该破坏性地修改contextValue参数。这确保了所有 resolver 之间的一致性并防止非预期错误的产生。 resolver 通过第三个参数可以访问共享的contextValue对象。为指定 operation 执行的所有 resolver 都可以访问contextValue： import { UserAPI } from &quot;./datasources/users&quot;; const resolvers = { Query: { // Our resolvers can access the fields in contextValue // from their third argument currentUser: (_, __, contextValue) =&gt; { return contextValue.dataSources.userApi.findUser(contextValue.token); }, }, }; interface MyContext { // Context typing token?: String; dataSources: { userApi: UserAPI; }; } const server = new ApolloServer&lt;MyContext&gt;({ typeDefs, resolvers, }); const { url } = await startStandaloneServer(server, { context: async ({ req }) =&gt; ({ token: getToken(req.headers.authentication), dataSources: { userApi: new UserAPI(), }, }), });  了解更多关于管理连接数据库或其他数据源，请参考Fetching Data 更多信息和示例，参考Sharing context。 ","version":"Next","tagName":"h3"},{"title":"返回值​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#返回值","content":"resolver 函数的返回值，根据它的类型被 Apollo Server 以不同方式处理。 类型\t描述scalar/object\tresolver 可以返回一个单独的值或对象，就像在Defining a schema中展示的一样。这个返回值通过parent参数，向下传递给任何嵌套的 resolver。 Array\t当且仅当 schema 与 resolver 关联的字段包含一个列表时，才返回一个数组。返回数组后，Apollo Server 对数组中的每一项执行嵌套 resolver。 null/undefined\t表明这个字段的值无法被找到。如果 scheme 标明 resolver 的字段可以为 null，那么这个 operation 的结果，在字段的位置会填充null作为返回值。如果 resolver 的字段不能为 null，Apollo Server 设置字段的父级为null。如有必要，这个过程持续向上 resolver chain 知道它到达一个可以为 null 的字段。这确保了返回值永远不会给一个不能为 null 的字段返回null。当出现这种情况时，响应中的errors属性将被填充与字段的是否允许为 null 相关的错误。 Promise\tresolver 可以异步，而且可以执行异步操作，例如从数据库或后端 API 获取数据。为了支持这些能力，resolver 可以返回 promise，该 promise 解析为任何其他支持的返回类型。 ","version":"Next","tagName":"h2"},{"title":"Default resolver​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#default-resolver","content":"如果不为指定的 schema 字段定义 resolver，Apollo Server 会给它定义一个 default resolver。 default resolver 函数的调用逻辑如下： 作为一个例子，思考下面 schema 片段： type Book { title: String } type Author { books: [Book] }  如果books字段的 resolver 返回一个对象的数组，每个对象包含title字段，你可以对title字段使用 default resolver。default resolver 将正确返回parent.title。 ","version":"Next","tagName":"h2"},{"title":"解析 union 和 interface​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#解析-union-和-interface","content":"这些 GraphQL 类型允许去定义一个返回多种可能对象类型中一种的字段。为了解析可以返回不同对象类型的字段，必须定义__resolveType函数去告知 Apollo Server 哪个对象的类型将被返回。 参考__resolveType函数的例子 ","version":"Next","tagName":"h2"},{"title":"解析 federated entities​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#解析-federated-entities","content":"参考Resolvering Entities ","version":"Next","tagName":"h2"},{"title":"监控 resolver 性能​","type":1,"pageTitle":"Resolvers","url":"/blog/docs/Apollo Server/Resolving Operations/resolvers#监控-resolver-性能","content":"与所有代码一样，resolver 的性能取决于它的逻辑。最重要的是理解哪些 schema 字段是计算成本高或解析缓慢，这样才能提升它们的性能或确保只在必要的时候查询这些字段。 Apollo Studio 直接集成 Apollo Server，以提供顶层字段的监控指标，这可以帮助及时了解 graph 的性能。更多信息，参考Analyzing performance ","version":"Next","tagName":"h2"}],"options":{"languages":["en","zh"],"id":"default"}}